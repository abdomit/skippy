#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        Skippy.py
## 
## Project :     SCPI
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Standard Commands for Programmable Instruments (SCPI) DeviceServer """

__all__ = ["Skippy", "SkippyClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(Skippy.additionnal_import) ENABLED START -----#
import socket
import threading
import time
import traceback
import communicator
import instructionSet
import numpy,struct,copy
from types import StringType
#----- PROTECTED REGION END -----#	//	Skippy.additionnal_import

##############################################################################
## Device States Description
##
## OFF : No connection stablished with the instrument.
## ON : Connection stablished with the instrument.
## RUNNING : Connection stablished and active monitoring.
## ALARM : Reported errors from the instrument.
## FAULT : Communication error with the instrument.
## INIT : Initialization stage.
## STANDBY : 
##############################################################################

class Skippy (PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------
#----- PROTECTED REGION ID(Skippy.global_variables) ENABLED START -----#

    ######
    #----- section to resolve instrument property
    def __buildInstrumentObj(self):
        try:
            self._instrument = communicator.buildCommunicator(self.Instrument,
                                                              self.Port,
                                                              self)
        except SyntaxError,e:
            self.error_stream("Error in the instrument name: %s"%(e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("%s: review the 'instrument' property"%(e))
            return False
        except Exception,e:
            self.error_stream("Generic exception: %s"%(e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("initialisation exception: %s"%(e))
            return False
        self.change_state(PyTango.DevState.OFF)
        return True

    def __connectInstrumentObj(self):
        if not hasattr(self,'_instrument') or self._instrument == None:
            self.error_stream("In %s.__connectInstrumentObj(): instrument "\
                              "object not build yet"%(self.get_name()))
            return False
        try:
            self._instrument.connect()
            self._idn = self._instrument.ask("*IDN?")
        except Exception,e:
            self.error_stream("Cannot connect to the instrument due to: %s"%e)
            return False
        else:
            self.info_stream("Connected to the instrument and "\
                             "identified as: %s"%(repr(self._idn)))
            return True
    
    def __reconnectInstrumentObj(self):
        if not hasattr(self,'_instrument') or self._instrument == None:
            self.error_stream("In %s.__reconnectInstrumentObj(): instrument "\
                              "object not build yet"%(self.get_name()))
            return False
        try:
            self._instrument.disconnect()
            self.change_state(PyTango.DevState.DISABLE)
        except Exception,e:
            self.error_stream("In %s.__reconnectInstrumentObj(): disconnect "\
                              "exception: %s"%(self.get_name(),e))
            self.change_state(PyTango.DevState.FAULT)
        self._instrument = None
        self.__buildInstrumentObj()#OFF
        self.__connectInstrumentObj()#STANDBY
        
    #----- done section to resolve instrument property
    ######
    
    ######
    #----- dynamic attributes builder section
    def __builder(self):
        try:
            instructionSet.identifier(self._idn,self)
        except Exception,e:
            msg = "identification error: %s (*IDN?:%s)"%(e,repr(self._idn))
            self.error_stream("%s %s"%(self.get_name(),msg))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg(msg)
            return False
        else:
            return True
        
    def __unbuilder(self):
        pass #TODO: remove all the dynamic attributes from the current builded.
    
    
    def __read_attr_procedure(self,data,fromMonitor=False):
        '''This method is the read_attr_hardware, but we had to distinguish 
           between monitoring calls for events than the direct requests to the 
           device. This is because, direct requests of monitored attributes 
           should not do a real hardware read.
           TODO: as all the readers (external or any of the monitors) will call
           this method, here is the place to implement the priorities.
        '''
        self.debug_stream("In %s.__read_attr_procedure(%s)"%(self.get_name(),repr(data)))
        try:
            multiattr = self.get_device_attr()
            scalarList,spectrumList,imageList = self.__filterAttributes(multiattr,data,fromMonitor)
            if not len(scalarList) == 0:
                indexes,queries = self.__preHardwareRead(scalarList,self.attr_QueryWindow_read)
                answers = []
                for query in queries:
                    answers.append(self.__hardwareRead(query))
                msg = ""
                for answer in answers:
                    if len(answer) > 100:
                        msg = ''.join([msg,"%s(...)%s"%(repr(answer[:25]),
                                    repr(answer[len(answer)-25:]))])
                    else:
                        msg = ''.join([msg,"%s"%(repr(answer))])
                self.debug_stream("In %s.__read_attr_procedure() scalar answers: %s"\
                                  %(self.get_name(),msg))
                self.__postHardwareScalarRead(indexes,answers)
            if not len(spectrumList) == 0:
                indexes,queries = self.__preHardwareRead(spectrumList,1)
                answers = []
                for query in queries:
                    answers.append(self.__hardwareRead(query))
                self.debug_stream("In %s.__read_attr_procedure() spectrum answers number: %s"\
                                  %(self.get_name(),len(answers)))
                self.__postHardwareSpectrumRead(indexes,answers)
            if not len(imageList) == 0:
                self.error_stream("Excluding 2 dimensional attributes")
        except Exception,e:
            self.error_stream("In %s.__read_attr_procedure() Exception: %s"\
                              %(self.get_name(),e))
    
    def __filterAttributes(self,multiattr,data,fromMonitor):
        '''Avoid hardware readings of:
           - attributes that are internals to the device
           - attributes that reading is recent
           - attributes where its channel/function manager say closed
        '''
        try:
            t = time.time()
            delta_t = self.attr_TimeStampsThreshold_read
            scalar = []
            spectrum = []
            image = []
            for attrIndex in data:
                attrObj = multiattr.get_attr_by_ind(attrIndex)
                attrName = attrObj.get_name()
                if not self.attributes.has_key(attrName):
                        self.debug_stream("In %s.__filterAttributes() "\
                                          "excluding %s: is not a hw attr."
                                          %(self.get_name(),attrName))
                else:
                    #filter attributes depending if they are monitored
                    if self.get_state() == PyTango.DevState.RUNNING and \
                       (fromMonitor and not attrIndex in self._monitoredAttributeIds) or\
                       (not fromMonitor and attrIndex in self._monitoredAttributeIds):
                        self.debug_stream("In %s.__filterAttributes() excluding "\
                                          "%s because the monitoring dependency"
                                          %(self.get_name(),attrName))
                    else:
                        #discard if the channel or function is not open
                        attrName = self.__checkChannelManager(attrName)
                        if attrName != None:
                            t_a = self.attributes[attrName]['timestamp']
                            attrObj = multiattr.get_attr_by_name(attrName)
                            if not attrIndex in self._monitoredAttributeIds and \
                               not t_a == None and t - t_a < delta_t:
                                self.debug_stream("In %s.__filterAttributes() "\
                                                  "excluding %s: t < delta_t"
                                                  %(self.get_name(),attrName))
                            else:
                                if attrObj.get_data_format() == PyTango.AttrDataFormat.SCALAR:
                                    scalar.append(attrName)
                                elif attrObj.get_data_format() == PyTango.AttrDataFormat.SPECTRUM:
                                    spectrum.append(attrName)
                                    #when an spectrum are required, some reference attributes will be needed
                                    if self.attributes.has_key('WaveformDataFormat'):
                                        scalar.append('WaveformDataFormat')
                                    if self.attributes.has_key('WaveformOrigin'):
                                        scalar.append('WaveformOrigin')
                                    if self.attributes.has_key('WaveformIncrement'):
                                        scalar.append('WaveformIncrement')
                                elif attrObj.get_data_format() == PyTango.AttrDataFormat.IMAGE:
                                    image.append(attrName)
                                else:
                                    self.error_stream("In %s.__filterAttributes() "\
                                                      "unknown data format for "\
                                                      "attribute %s"%(self.get_name(),attrName))
            self.debug_stream("In %s.__filterAttributes() scalar list: %s; "\
                              "spectrum list: %s; image list: %s"
                              %(self.get_name(),scalar,spectrum,image))
            #Remove repeated attributes
            for attr in scalar:
                while scalar.count(attr) > 1:
                    scalar.pop(scalar.index(attr))
            for attr in spectrum:
                while spectrum.count(attr) > 1:
                    spectrum.pop(spectrum.index(attr))
            for attr in image:
                while image.count(attr) > 1:
                    image.pop(image.index(attr))
            return scalar,spectrum,image
        except Exception,e:
            self.error_stream("In %s.__filterAttributes(%s) Exception: %s"
                              %(self.get_name(),data,e))
            traceback.print_exc()
            return None
        
    def __checkChannelManager(self,attrName):
        if attrName[-3:-1] in ['Ch','Fn']:
            managerName = self.attributesFlags[attrName[-3:]]
            managerValue = self.attributes[managerName]['lastReadValue']
            if managerValue == None:
                return managerName
            elif managerValue == False:
                self.debug_stream("In %s.__checkChannelManager() "\
                                  "excluding %s from filter: channel or "\
                                  "function is close"%(self.get_name(),attrName))
                return None
            else:
                return attrName
        else:#non channel or function no sub-filter
            return attrName
    
    def __preHardwareRead(self,attrList,window=1):
        '''Given a list of attributes to be read, prepare it.
           - Divide the attributes to be read in subsets of QueryWindow size.
           - Build the concatenations of queries per subset.
           Example: QueryWindow = 4
           Input: attrList = [a1,a2,a3,a4,a5,a6,a7,a8,a9,a10]
           Output: subsetsIndexes = [[a1,a2,a3,a4],
                                     [a5,a6,a7,a8],
                                     [a9,a10]]
                   subsetsQueries = ["cmd;cmd;cmd;cmd;",
                                     "cmd;cmd;cmd;cmd;",
                                     "cmd;cmd;"]
        '''
        try:
            #self.debug_stream("In %s.__preHardwareRead()"%self.get_name())
            subsetsIndexes = []
            subsetsQueries = []
            for i in range(0,len(attrList),window):
                subsetsIndexes.append(attrList[i:i+window])
                subsetsQueries.append("")
                for j in range(len(subsetsIndexes[len(subsetsIndexes)-1])):
                    attrName = subsetsIndexes[len(subsetsIndexes)-1][j]
                    attrCmd = self.attributes[attrName]['readStr']
                    subsetsQueries[len(subsetsQueries)-1] = "%s%s;"%(subsetsQueries[len(subsetsQueries)-1],attrCmd)
            return subsetsIndexes,subsetsQueries
        except Exception,e:
            self.error_stream("In %s.__preHardwareRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
            return None,None

    def __hardwareRead(self,query):
        '''Given a string with a ';' separated list of scpi commands 'ask'
           to the instrument and return what the instrument responds.
        '''
        #self.debug_stream("In %s.__hardwareRead()"%self.get_name())
        try:
            return self._instrument.ask(query)
        except Exception,e:
            self.error_stream("In %s.__hardwareRead() Exception: %s"%(self.get_name(),e))
            traceback.print_exc()
            self.__reconnectInstrumentObj()

    def __postHardwareScalarRead(self,indexes,answers):
        '''Given the answers organise them in the self.attributes dictionary.
           Example: QueryWindow = 4
           Input: indexes = [[a1,a2,a3,a4],
                             [a5,a6,a7,a8],
                             [a9,a10]]
                  answers = ["ans;ans;ans;ans;",
                             "ans;ans;ans;ans;",
                             "ans;ans;"]
        '''
        #self.debug_stream("In %s.__postHardwareScalarRead()"%self.get_name())
        t = time.time()
        try:
            attrWithEvents = []
            for i,answer in enumerate(answers):
                for j,value in enumerate(answer.split('\n')[0].split(';')):
                    attrName = indexes[i][j]
                    try:
                        if self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevBoolean]:
                            self.attributes[attrName]['lastReadValue'] = bool(int(value))
                            self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevUChar,
                                                                   PyTango.CmdArgType.DevUShort,
                                                                   PyTango.CmdArgType.DevShort,
                                                                   PyTango.CmdArgType.DevULong,
                                                                   PyTango.CmdArgType.DevLong,
                                                                   PyTango.CmdArgType.DevULong64,
                                                                   PyTango.CmdArgType.DevLong64]:
                            self.attributes[attrName]['lastReadValue'] = int(value)
                            self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevFloat,
                                                                   PyTango.CmdArgType.DevDouble]:
                            if value == '9.99999E+37':#this is the instrument tag for non measurable
                                self.attributes[attrName]['lastReadValue'] = float('NaN')
                                self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_WARNING
                            else:
                                self.attributes[attrName]['lastReadValue'] = float(value)
                                self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevString]:
                            self.attributes[attrName]['lastReadValue'] = str(value)
                            self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                        else:
                            self.warn_stream("In %s.__postHardwareScalarRead() "\
                                             "Unrecognized data type for %s"
                                             %(self.get_name(),attrName))
                            self.attributes[attrName]['lastReadValue'] = value
                    except Exception,e:
                        self.error_stream("In %s.__postHardwareScalarRead() "\
                                          "Exception of attribute %s: %s"
                                          %(self.get_name(),attrName,e))
                        self.attributes[attrName]['lastReadValue'] = None
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_INVALID
                    finally:
                        self.attributes[attrName]['timestamp'] = t
                        multiattr = self.get_device_attr()
                        attrId = multiattr.get_attr_ind_by_name(attrName)
                        if attrId in self._monitoredAttributeIds:
                            #self.debug_stream("Append %s to fire events"%(attrName))
                            attrWithEvents.append([attrName,
                                                   self.attributes[attrName]['lastReadValue'],
                                                   self.attributes[attrName]['quality']
                                                 ])
            #self.debug_stream("to fire events: %s"%(repr(attrWithEvents)))
            self.fireEventsList(attrWithEvents)
        except Exception,e:
            self.error_stream("In %s.__postHardwareScalarRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
    
    def __postHardwareSpectrumRead(self,indexes,answers):
        '''Given the answers organise them in the self.attributes dictionary.
           QueryWindow doesn't apply here, the spectrums are made in separated reads
           Input: indexes = [[s1],
                             [s2],
                             [a3]]
                  answers = ["f1,f2,f3,f4,...,fn",
                             "f1,f2,f3,f4,...,fn",,
                             "f1,f2,f3,f4,...,fn",]
           A waveform has always a first character '#'
           The second is a char with the number of elements in the next variable field
           The third, represented with Rs, are the number of elements in the waveform that comes next.
           Example: answer = #532017... means, 5 elements will be in the second
                    field, and there will be 32017 elements in the third.
        '''
        #self.debug_stream("In %s.__postHardwareSpectrumRead()"%self.get_name())
        t = time.time()
        try:
            attrWithEvents = []
            for i,answer in enumerate(answers):
                attrName = indexes[i][0]
                if self.attributes.has_key('WaveformDataFormat') and \
                   self.attributes.has_key('WaveformOrigin') and \
                   self.attributes.has_key('WaveformIncrement'):
                    dataFormat = self.attributes['WaveformDataFormat']['lastReadValue']
                    if dataFormat.startswith('ASC'):
                        #self.debug_stream("Spectrum received in ascii: %s"%(repr(answer)[:100]))
                        self.attributes[attrName]['lastReadRaw'] = answer
                        self.attributes[attrName]['lastReadValue'] = numpy.fromstring(answer,dtype=float,sep=',')
                        self.attributes[attrName]['timestamp'] = t
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                    else:
                        #self.debug_stream("Spectrum received in binary: %s...%s"
                        #                  %(repr(answer[:25]),repr(answer[len(answer)-25:])))
                        #process the header
                        if not answer[0] == '#':
                            self.error_stream("Wrong data receiver for the "\
                                              "attribute %s"%attrName)
                            return
                        #save values for debugging
                        self.attributes[attrName]['lastReadRaw'] = answer
                        #review the header
                        nBytesLengthBlock = int(answer[1])
                        nBytesWaveBlock = int(answer[2:nBytesLengthBlock+2])
                        waveBytes = answer[nBytesLengthBlock+2:nBytesWaveBlock]
                        self.debug_stream("In %s.__postHardwareSpectrumRead() "\
                                          "waveform data: header size %d bytes, "\
                                          "wave size %d bytes"
                                          %(self.get_name(),nBytesLengthBlock,nBytesWaveBlock))
                        #prepare interpretation of the raw data
                        if dataFormat.startswith('BYT'):
                            format = 'b'#signed char, 1byte
                            divisor = 1
                        elif dataFormat.startswith('WORD'):
                            format = 'h'#signed short, 2byte
                            divisor = 2
#                             elif dataFormat.startswith('LON'):
#                                 pass
                        else:
                            self.error_stream("Cannot decodify data receiver "\
                                              "for the attribute %s"%attrName)
                            self.attributes[attrName]['lastReadValue'] = []
                            self.attributes[attrName]['timestamp'] = t
                            self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_INVALID
                        nCompletBytes = len(waveBytes)-(len(waveBytes)%divisor)
                        if not len(waveBytes)%4 == 0:
                            self.debug_stream("nIncompleteBytes = %d"%(len(waveBytes)%divisor))
                        #convert the received input to integers
                        unpackInt = struct.unpack(format*(nCompletBytes/divisor),waveBytes[:nCompletBytes])
                        #expand the input when each float is codified in less than 4 bytes
                        floats = numpy.array(unpackInt,dtype=float)
                        waveorigin = self.attributes['WaveformOrigin']['lastReadValue']
                        waveincrement = self.attributes['WaveformIncrement']['lastReadValue']
                        self.attributes[attrName]['lastReadValue'] = (waveorigin + (waveincrement * floats))
                        self.attributes[attrName]['timestamp'] = t
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                else:
                    self.warn_stream("In %s.__postHardwareSpectrumRead() "\
                                     "Unrecognised spectrum attribute, "\
                                     "storing raw data"%(self.get_name()))
                    self.attributes[attrName]['lastReadValue'] = answer
                    self.attributes[attrName]['timestamp'] = t
                    self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                multiattr = self.get_device_attr()
                attrId = multiattr.get_attr_ind_by_name(attrName)
                if attrId in self._monitoredAttributeIds:
                    attrWithEvents.append([
                                           attrName,
                                           self.attributes[attrName]['lastReadValue'],
                                           self.attributes[attrName]['quality']
                                         ])
            #self.debug_stream("to fire events: %s"%(repr(attrWithEvents)))
            self.fireEventsList(attrWithEvents)
        except Exception,e:
            self.error_stream("In %s.__postHardwareSpectrumRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
    
    @instructionSet.AttrExc
    def read_attr(self, attr):
        attrName = attr.get_name()
        #self.debug_stream("read_attr for %s"%(attrName))
        if self.attributes.has_key(attrName):
            value = self.attributes[attrName]['lastReadValue']
            timestamp = self.attributes[attrName]['timestamp']
            quality = self.attributes[attrName]['quality']
            if self.attributes[attrName]['dim'] == 0:
                if value == None:
                    attr.set_value_date_quality(0,time.time(),PyTango.AttrQuality.ATTR_INVALID)
                else:
                    attr.set_value_date_quality(value,timestamp,quality)
            elif self.attributes[attrName]['dim'] == 1:
                if value == None:
                    attr.set_value_date_quality([0],time.time(),PyTango.AttrQuality.ATTR_INVALID,1)
                else:
                    attr.set_value_date_quality(value,timestamp,quality,len(value))
        elif attrName.endswith("Step"):
            parentAttrName = attrName.split('Step')[0]
            print parentAttrName
            value = self.attributes[parentAttrName]['rampStep']
            print self.attributes[parentAttrName]
            if value == None:
                attr.set_value_date_quality(0,time.time(),PyTango.AttrQuality.ATTR_INVALID)
            else:
                attr.set_value(value)
        elif attrName.endswith("StepSpeed"):
            parentAttrName = attrName.split('StepSpeed')[0]
            print parentAttrName
            value = self.attributes[parentAttrName]['rampStepSpeed']
            print self.attributes[parentAttrName]
            if value == None:
                attr.set_value_date_quality(0,time.time(),PyTango.AttrQuality.ATTR_INVALID)
            else:
                attr.set_value(value)
        else:
            raise AttributeError("Invalid read of the attribute %s"
                                 %(attrName))

    @instructionSet.AttrExc
    def write_attr(self, attr):
        '''The execution of this method starts with three different branches:
           - An instrument attribute to be send. This splits in two branches also:
             - Direct write
             - Launch a thread (if not yet) to drive a ramp to the setpoint
           - The other two are the internal ramp attributes
           - Other case, raise an exception
        '''
        attrName = attr.get_name()
        data = []
        attr.get_write_value(data)
        if self.attributes.has_key(attrName):
            self.__write_instrument_attr(attr,attrName,data)
        elif attrName.endswith("Step"):
            parentAttrName = attrName.split('Step')[0]
            self.attributes[parentAttrName]['rampStep'] = data[0]
        elif attrName.endswith("StepSpeed"):
            parentAttrName = attrName.split('StepSpeed')[0]
            self.attributes[parentAttrName]['rampStepSpeed'] = data[0]
        else:
            raise AttributeError("Invalid write of the attribute %s"
                                 %(attrName))

    def __write_instrument_attr(self,attr,attrName,data):
        self.attributes[attrName]['lastWriteValue'] = data[0]
        #Normal case, non rampable attribute
        if not self.attributes[attrName].has_key('rampThread'):
            cmd = self.attributes[attrName]['writeStr'](data[0])
            #filter the write value if the attribute was configured this way
            if self.attributes[attrName].has_key('writeValues') and \
               not data[0].upper() in self.attributes[attrName]['writeValues']:
                self.error_stream("In %s.__write_instrument_attr() avoid to send: %s"
                                  %(self.get_name(),cmd))
                raise AttributeError("Invalid write value %s of the attribute %s"
                                     %(repr(data[0]),attrName))
            else:
                self.debug_stream("In %s.__write_instrument_attr() sending: %s"
                                  %(self.get_name(),cmd))
                self._instrument.write(cmd)
        else:
            #rampeable but invalid ramp
            if not self.attributes[attrName]['rampStep'] in [None,0.0] or \
               not self.attributes[attrName]['rampStepSpeed'] in [None,0.0]:
                cmd = self.attributes[attrName]['writeStr'](data[0])
                self.debug_stream("In %s.__write_instrument_attr() sending: %s"
                                  %(self.get_name(),cmd))
                self._instrument.write(cmd)
            else:
                #rampeable and create a thread, if it doesn't exist
                if self.attributes[attrName]['rampThread'] == None:
                    self.attributes[attrName]['rampThread'] = threading.Thread(target=self.rampStepper,
                                                                               args=([attrName]))
                    self.attributes[attrName]['rampThread'].setDaemon(True)
                    self.attributes[attrName]['rampThread'].start()
                #no else need because during the ramp the it goes to 
                #'lastWriteValue' and it has been already updated.

    def rampStepper(self,attrName):
        #Remember the arguments when this is called as thread target, is a tuple
        # and the content of this tuple is a list with one string element.
        self.debug_stream("In %s.rampStepper(%s)"%(self.get_name(),attrName))
        #prepare
        backup_state = self.get_state()
        self.change_state(PyTango.DevState.MOVING)
        attrReadCmd = self.attributes[attrName]['readStr']
        #move
        self.attributes[attrName]['lastReadValue'] = float(self._instrument.ask(attrReadCmd))
        current_pos = self.attributes[attrName]['lastReadValue']
        self.info_stream("In %s.rampSteeper(): started the movement from %f"
                         %(self.get_name(),current_pos))
        while not current_pos == self.attributes[attrName]['lastWriteValue']:
            if current_pos > self.attributes[attrName]['lastWriteValue']:
                if current_pos - self.attributes[attrName]['lastWriteValue'] < self.attributes[attrName]['rampStep']:
                    current_pos = self.attributes[attrName]['lastWriteValue']
                else: current_pos -= self.attributes[attrName]['rampStep']
            elif current_pos < self.attributes[attrName]['lastWriteValue']:
                if self.attributes[attrName]['lastWriteValue'] - current_pos < self.attributes[attrName]['rampStep']:
                    current_pos = self.attributes[attrName]['lastWriteValue']
                else: current_pos += self.attributes[attrName]['rampStep']
            attrWriteCmd = self.attributes[attrName]['writeStr'](current_pos)
            #self.debug_stream("In %s.write_attr() sending: %s"%(self.get_name(),attrWriteCmd))
            self._instrument.write(attrWriteCmd)
            time.sleep(self.attributes[attrName]['rampStepSpeed'])
        self.info_stream("In %s.rampSteeper(): finished the movement at %f"
                         %(self.get_name(),current_pos))
        #close
        self.change_state(backup_state)
        self.attributes[attrName]['rampThread'] = None

    #----- done dynamic attributes builder section
    ######

    ######
    #----- event manager section
    def fireEventsList(self,eventsAttrList):
        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                #self.debug_stream("In %s.fireEventsList() attribute: %s"%(self.get_name(),attrEvent[0]))
                if len(attrEvent) == 3:#specifies quality
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,PyTango.AttrQuality.ATTR_VALID)
            except Exception,e:
                self.error_stream("In %s.fireEventsList() Exception with attribute %s: %s"%(self.get_name(),attrEvent[0],e))
                traceback.print_exc()
    #@todo: clean the important logs when they loose importance.
    def change_state(self,newstate):
        self.debug_stream("In %s.change_state(%s)"%(self.get_name(),str(newstate)))
        if newstate != self.get_state():
            self.set_state(newstate)
            self.push_change_event('State',newstate)
    def cleanAllImportantLogs(self):
        self.debug_stream("In %s.cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")
    def addStatusMsg(self,newStatusLine,important = False):
        self.debug_stream("In %s.addStatusMsg()"%self.get_name())
        msg = "The device is in %s state.\n"%(self.get_state())
        for ilog in self._important_logs:
            msg = "%s%s\n"%(msg,ilog)
        status = "%s%s"%(msg,newStatusLine)
        self.set_status(status)
        self.push_change_event('Status',status)
        if important and not newStatusLine in self._important_logs:
            self._important_logs.append(newStatusLine)
    def rebuildStatus(self):
        self.cleanAllImportantLogs()
        self.addStatusMsg("Attributes monitored: %s"
                          %(repr(self.MonitoredAttributes)),important=True)
        self.addStatusMsg("Attributes %s required too much time to be read"
                          %(repr(self._alarmDueToMonitoring)), important=True)
    #----- done event manager section
    ######
    
    ######
    #----- attribute monitor section
    def __builtMonitorThread(self,name,period):
        scheleton = {'Name':name,#Only used to output a message when threads start
                     'Thread':None,
                     'Event':threading.Event(),
                     'Period':period,
                     'AttrList':[],
                    }
        scheleton['Event'].clear()
        return scheleton
    
    def __prepareMonitor(self):
        ''' - The lines in the property 'MonitoredAttributes' defines an attribute
            name to be monitored (with an optional tag of an special period):
                attrName[:period]
            - The attributes must be stored in an Id way in a list, to simplify 
            the filter when 'self.read_attr_hardware()' is called by a 
            PyTango.DeviceProxy.read_attributes([]) or PyTango.DeviceProxy.read_attribute()
            - There is a thread for generic monitoring, the period of it
            is the 'TimeStampsThreashold' to have it as updated as possible.
            - Other periods will collect the ones with the same period in one thread.
            - The monitored attributes will have events.
        '''
        try:
            multiattr = self.get_device_attr()
            self._monitorThreads = {}
            self._generalMonitorEvent = threading.Event()
            self._generalMonitorEvent.clear()
            self._monitoredAttributeIds = []
            self._alarmDueToMonitoring = []
            for attrName in self.MonitoredAttributes:
                if not attrName.count(':'):#Normal monitoring
                    monitoringType = 'Generic'
                    attrPeriod = self.attr_TimeStampsThreshold_read
                    attrId = multiattr.get_attr_ind_by_name(attrName)
                else:
                    attrName,attrPeriod = attrName.split(':')
                    monitoringType = attrPeriod
                    attrPeriod = float(attrPeriod)
                    attrId = multiattr.get_attr_ind_by_name(attrName)
                #Once inicialised they can be build by reference
                if not attrName in self.attributes.keys():
                    self.error_stream("The name %s is not an attribute in "\
                                      "this device"%(attrName))
                elif attrId in self._monitoredAttributeIds:
                    self.error_stream("The attribute %s is configured to "\
                                      "be monitored more than one time"
                                      %(attrName))
                else:#once here link it with the appropriate thread
                    self.debug_stream("Preparing the attribute %s for "\
                                      "the %s monitoring"
                                      %(attrName,monitoringType))
                    self._monitoredAttributeIds.append(attrId)
                    if not self._monitorThreads.has_key(monitoringType):
                        self._monitorThreads[monitoringType] = self.__builtMonitorThread(monitoringType,attrPeriod)
                    self._monitorThreads[monitoringType]['AttrList'].append(attrName)
        except Exception,e:
            self.error_stream("In %s.__prepareMonitor() Exception: %s"%(self.get_name(),e))

    def __startMonitoring(self):
        try:
            self._generalMonitorEvent.clear()
            for monitorTag in self._monitorThreads.keys():
                self._monitorThreads[monitorTag]['Thread'] = threading.Thread(target=self.__monitor,
                                                           args=([self._monitorThreads[monitorTag]]))
                self._monitorThreads[monitorTag]['Event'].clear()
                self._monitorThreads[monitorTag]['Thread'].setDaemon(True)
                for attrName in self._monitorThreads[monitorTag]['AttrList']:
                    self.set_change_event(attrName,True,False)
                self._monitorThreads[monitorTag]['Thread'].start()
            self.change_state(PyTango.DevState.RUNNING)
        except Exception,e:
            self.error_stream("In %s.__startMonitoring() Exception: %s"%(self.get_name(),e))
            
    def __endMonitoring(self):
        self.info_stream("In %s.__endMonitoring() waiting for %d"%(self.get_name(),len(self._monitorThreads.keys())))
        self._generalMonitorEvent.set()
        while any([self._monitorThreads[monitorTag]['Thread'].isAlive() for monitorTag in self._monitorThreads.keys()]):
            self.info_stream("In %s.__endMonitoring() waiting for %d"%(self.get_name(),len(self._monitorThreads.keys())))
            time.sleep(0.5)
        self.change_state(PyTango.DevState.ON)
        self.__prepareMonitor()

    def __buildIdList(self,attrList):
        multiattr = self.get_device_attr()
        IdsList = []
        for attrName in attrList:
            IdsList.append(multiattr.get_attr_ind_by_name(attrName))
        return IdsList

    def __monitor(self,monitorDict):
        '''This is the method where every monitor thread will live.
        '''
        self.info_stream("Monitoring thread '%s' announcing its START. "\
                         "Attributes: %s"%(monitorDict['Name'],repr(monitorDict['AttrList'])))
        attrList = []
        while not self._generalMonitorEvent.is_set() and \
              not monitorDict['Event'].is_set():
            if not len(attrList) == len(monitorDict['AttrList']):
                attrList = copy.copy(monitorDict['AttrList'])
                attrIds = self.__buildIdList(monitorDict['AttrList'])
                self.info_stream("In %s.__monitor(), thread %s, the "\
                                 "attribute list has change to %s"
                                 %(self.get_name(),monitorDict['Name'],
                                   repr(monitorDict['AttrList'])))
            if len(attrList) == 0:
                monitorDict['Event'].set()
            else:
                t0 = time.time()
                self.__read_attr_procedure(attrIds,fromMonitor=True)
                tf = time.time()
                delta_t = monitorDict['Period']-(tf-t0)
                if delta_t <= 0:#it take longer than the period
                    self.__appendToAlarmCausingList(attrList)
                else:
                    if self.get_state() == PyTango.DevState.ALARM:
                        self.__removeFromAlarmCausingList(attrList)
                    time.sleep(delta_t)
        self.info_stream("Monitoring thread %s announcing its STOP"%(monitorDict['Name']))
        for AttrName in monitorDict['AttrList']:
            self.set_change_event(AttrName,False,False)
        self._monitorThreads.pop(monitorDict['Name'])

    def __appendToAlarmCausingList(self,attrList):
        for attrName in attrList:
            if not attrName in self._alarmDueToMonitoring:
                self._alarmDueToMonitoring.append(attrName)
        self.rebuildStatus()

    def __removeFromAlarmCausingList(self,attrList):
        for attrName in attrList:
            if self._alarmDueToMonitoring.count(attrName):
                self._alarmDueToMonitoring.pop(self._alarmDueToMonitoring.index(attrName))
        self.rebuildStatus()

    def __appendPropertyElement(self,propertyName,element):
        db = PyTango.Database()
        propertiesDict = db.get_device_property(self.get_name(),propertyName)
        propertiesDict[propertyName].append(element)
        db.put_device_property(self.get_name(),propertiesDict)
        return propertiesDict[propertyName]
    def __popPropertyElement(self,propertyName,element):
        db = PyTango.Database()
        propertiesDict = db.get_device_property(self.get_name(),propertyName)
        propertyList = list(propertiesDict[propertyName])
        try:
            index = propertyList.index(element)
        except:
            #in case is an specially monitored, previous will throw an exception
            for name in propertyList:
                if name.startswith(element):
                    #find in the list something that starts with the attrName
                    #that continues with ':' and the period
                    index = propertyList.index(name)
                    break
        self.debug_stream("In %s.__popPropertyElement() removing %s (index %d)"
                          %(self.get_name(),propertyName,index))
        propertyList.pop(index)
        propertiesDict[propertyName] = propertyList
        db.put_device_property(self.get_name(),propertiesDict)
        return propertiesDict[propertyName]
    #----- done attribute monitor section
    ######

#----- PROTECTED REGION END -----#	//	Skippy.global_variables
#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In " + self.get_name() + ".__init__()")
        Skippy.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.debug_stream("In " + self.get_name() + ".delete_device()")
        #----- PROTECTED REGION ID(Skippy.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.delete_device

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.debug_stream("In " + self.get_name() + ".init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Idn_read = ''
        self.attr_QueryWindow_read = 0
        self.attr_TimeStampsThreshold_read = 0.0
        #----- PROTECTED REGION ID(Skippy.init_device) ENABLED START -----#
        self.set_change_event('State',True,False)
        self.set_change_event('Status',True,False)
        self._important_logs = []
        self.change_state(PyTango.DevState.INIT)
        self.attr_QueryWindow_read = 1#Not allow 0
        #tools for the Exec() cmd
        DS_MODULE = __import__(self.__class__.__module__)
        kM = dir(DS_MODULE)
        vM = map(DS_MODULE.__getattribute__, kM)
        self.__globals = dict(zip(kM, vM))
        self.__globals['self'] = self
        self.__globals['module'] = DS_MODULE
        self.__locals = {}
        #prepare the attribute building
        self.attributes={}
        self.attributesFlags = {}
        self.get_device_properties(self.get_device_class())
        #---- once initialized, begin the process to connect with the instrument
        self._instrument = None
        self.__buildInstrumentObj()
        if not self.AutoStandby:
            return
        self.Standby()
        if not self.AutoOn:
            return
        self.On()
        #TODO: flag to distinguish the minimal communications in STANDBY and
        #      the normal queries of the ON
        if not self.AutoStart:
            return
        self.Start()
        #----- PROTECTED REGION END -----#	//	Skippy.init_device

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.debug_stream("In " + self.get_name() + ".always_excuted_hook()")
        #----- PROTECTED REGION ID(Skippy.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.always_executed_hook

#==================================================================
#
#    Skippy read/write attribute methods
#
#==================================================================

#------------------------------------------------------------------
#    Read Idn attribute
#------------------------------------------------------------------
    def read_Idn(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_Idn()")
        #----- PROTECTED REGION ID(Skippy.Idn_read) ENABLED START -----#
        try:
            self.attr_Idn_read = self._idn
        except:
            attr.set_value_date_quality("",time.time(),PyTango.AttrQuality.ATTR_INVALID)
            return
        #----- PROTECTED REGION END -----#	//	Skippy.Idn_read
        attr.set_value(self.attr_Idn_read)
        
#------------------------------------------------------------------
#    Is Idn attribute allowed
#------------------------------------------------------------------
    def is_Idn_allowed(self, attr):
        self.debug_stream("In " + self.get_name() + ".is_Idn_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        
#------------------------------------------------------------------
#    Read QueryWindow attribute
#------------------------------------------------------------------
    def read_QueryWindow(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_QueryWindow()")
        #----- PROTECTED REGION ID(Skippy.QueryWindow_read) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.QueryWindow_read
        attr.set_value(self.attr_QueryWindow_read)
        
#------------------------------------------------------------------
#    Write QueryWindow attribute
#------------------------------------------------------------------
    def write_QueryWindow(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_QueryWindow()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(Skippy.QueryWindow_write) ENABLED START -----#
        self.attr_QueryWindow_read = int(data)
        #----- PROTECTED REGION END -----#	//	Skippy.QueryWindow_write
        
#------------------------------------------------------------------
#    Read TimeStampsThreshold attribute
#------------------------------------------------------------------
    def read_TimeStampsThreshold(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_TimeStampsThreshold()")
        #----- PROTECTED REGION ID(Skippy.TimeStampsThreshold_read) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.TimeStampsThreshold_read
        attr.set_value(self.attr_TimeStampsThreshold_read)
        
#------------------------------------------------------------------
#    Write TimeStampsThreshold attribute
#------------------------------------------------------------------
    def write_TimeStampsThreshold(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_TimeStampsThreshold()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(Skippy.TimeStampsThreshold_write) ENABLED START -----#
        self.attr_TimeStampsThreshold_read = float(data)
        if hasattr(self,'_monitorThreads') and self._monitorThreads.has_key('Generic'):
            self._monitorThreads['Generic']['Period'] = self.attr_TimeStampsThreshold_read
        #----- PROTECTED REGION END -----#	//	Skippy.TimeStampsThreshold_write
        



#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self, data):
        self.debug_stream("In " + self.get_name() + ".read_attr_hardware()")
        #----- PROTECTED REGION ID(Skippy.read_attr_hardware) ENABLED START -----#
        self.__read_attr_procedure(data)
        #----- PROTECTED REGION END -----#	//	Skippy.read_attr_hardware


#==================================================================
#
#    Skippy command methods
#
#==================================================================

#------------------------------------------------------------------
#    IDN command:
#------------------------------------------------------------------
    def IDN(self):
        """ Request identification to the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In " + self.get_name() +  ".IDN()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.IDN) ENABLED START -----#
        self._idn = self._instrument.ask("*IDN?")
        argout = self._idn
        #----- PROTECTED REGION END -----#	//	Skippy.IDN
        return argout
        
#------------------------------------------------------------------
#    Is IDN command allowed
#------------------------------------------------------------------
    def is_IDN_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_IDN_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
#------------------------------------------------------------------
#    Start command:
#------------------------------------------------------------------
    def Start(self):
        """ Start an active monitoring.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Start()")
        #----- PROTECTED REGION ID(Skippy.Start) ENABLED START -----#
        if self.get_state() == PyTango.DevState.ON:
            self.__startMonitoring()
        #----- PROTECTED REGION END -----#	//	Skippy.Start
        
#------------------------------------------------------------------
#    Is Start command allowed
#------------------------------------------------------------------
    def is_Start_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_Start_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.STANDBY])
#------------------------------------------------------------------
#    Stop command:
#------------------------------------------------------------------
    def Stop(self):
        """ Stop the active monitoring.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Stop()")
        #----- PROTECTED REGION ID(Skippy.Stop) ENABLED START -----#
        stopper = threading.Thread(target=self.__endMonitoring)
        stopper.setDaemon(True)
        stopper.start()
        #----- PROTECTED REGION END -----#	//	Skippy.Stop
        
#------------------------------------------------------------------
#    Is Stop command allowed
#------------------------------------------------------------------
    def is_Stop_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_Stop_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.ON,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.STANDBY])
#------------------------------------------------------------------
#    On command:
#------------------------------------------------------------------
    def On(self):
        """ Allow communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".On()")
        #----- PROTECTED REGION ID(Skippy.On) ENABLED START -----#
        if self.__builder():
            self.__prepareMonitor()
            self.change_state(PyTango.DevState.ON)
        #----- PROTECTED REGION END -----#	//	Skippy.On
        
#------------------------------------------------------------------
#    Off command:
#------------------------------------------------------------------
    def Off(self):
        """ Release the communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Off()")
        #----- PROTECTED REGION ID(Skippy.Off) ENABLED START -----#
        try:
            self._instrument.close()
        except:
            self.error_stream("Cannot disconnect from the instrument")
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Off command failed")
        else:
            self._idn = ""
            self.info_stream("disconnected to the instrument %s"
                             %(self.Instrument))
            self.change_state(PyTango.DevState.OFF)
            self.unbuilder()
        #----- PROTECTED REGION END -----#	//	Skippy.Off
        
#------------------------------------------------------------------
#    Is Off command allowed
#------------------------------------------------------------------
    def is_Off_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_Off_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
#------------------------------------------------------------------
#    Exec command:
#------------------------------------------------------------------
    def Exec(self, argin):
        """ evaluate python code inside the device server. This command can be very helpful and dangerous.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In " + self.get_name() +  ".Exec()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.Exec) ENABLED START -----#
        try:
            try:
                # interpretation as expression
                argout = eval(argin,self.__globals,self.__locals)
            except SyntaxError:
                # interpretation as statement
                exec argin in self.__globals, self.__locals
                argout = self.__locals.get("y")

        except Exception, exc:
            # handles errors on both eval and exec level
            argout = traceback.format_exc()

        if type(argout)==StringType:
            return argout
        elif isinstance(argout, BaseException):
            return "%s!\n%s" % (argout.__class__.__name__, str(argout))
        else:
            try:
                return pprint.pformat(argout)
            except Exception:
                return str(argout)
        #----- PROTECTED REGION END -----#	//	Skippy.Exec
        return argout
        
#------------------------------------------------------------------
#    AddMonitoring command:
#------------------------------------------------------------------
    def AddMonitoring(self, argin):
        """ Add an attribute to the list of monitored attributes
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".AddMonitoring()")
        #----- PROTECTED REGION ID(Skippy.AddMonitoring) ENABLED START -----#
        try:
            attrName = argin
            multiattr = self.get_device_attr()
            attrId = multiattr.get_attr_ind_by_name(attrName)
            if not attrName in self.attributes.keys():
                raise AttributeError("No attribute named %s"%(attrName))
            elif attrId in self._monitoredAttributeIds:
                raise AttributeError("Attribute %s already monitored"%(attrName))
            else:
                self.info_stream("In %s.AddMonitoring(): Adding %s attribute "\
                                 "to monitoring."%(self.get_name(),attrName))
                #manage the property
                try:
                    self.MonitoredAttributes = self.__appendPropertyElement('MonitoredAttributes',argin)
                except Exception,e:
                    self.error_stream("In %s.AddMonitoring(%s) cannot append "\
                                      "to the property: %s"%
                                      (self.get_name(),attrName,e))
                    raise e
                #manage the internal list that monitors
                monitoringType = 'Generic'
                if self._monitorThreads.has_key(monitoringType):
                    self.debug_stream("Adding %s to generic monitoring thread"
                                      %(attrName))
                    self._monitoredAttributeIds.append(attrId)
                    self._monitorThreads[monitoringType]['AttrList'].append(attrName)
                    self.set_change_event(attrName,True,False)
                self.rebuildStatus()
        except Exception,e:
            self.error_stream("In %s.AddMonitoring(%s) exception: %s"%
                              (self.get_name(),argin,e))
            raise e
        #----- PROTECTED REGION END -----#	//	Skippy.AddMonitoring
        
#------------------------------------------------------------------
#    Is AddMonitoring command allowed
#------------------------------------------------------------------
    def is_AddMonitoring_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_AddMonitoring_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
#------------------------------------------------------------------
#    RemoveMonitoring command:
#------------------------------------------------------------------
    def RemoveMonitoring(self, argin):
        """ Remove an attribute from the list of monitored attributes
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".RemoveMonitoring()")
        #----- PROTECTED REGION ID(Skippy.RemoveMonitoring) ENABLED START -----#
        try:
            multiattr = self.get_device_attr()
            attrId = multiattr.get_attr_ind_by_name(argin)
            if not argin in self.attributes.keys():
                raise AttributeError("No attribute named %s"%(argin))
            elif not attrId in self._monitoredAttributeIds:
                raise AttributeError("Attribute %s is not monitored"%(argin))
            else:
                #manage the internal monitors
                self.info_stream("In %s.RemoveMonitoring(): Removing %s "\
                                 "attribute from monitoring"
                                 %(self.get_name(),argin))
                for monitorKey in self._monitorThreads.keys():
                    if self._monitorThreads[monitorKey]['AttrList'].count(argin):
                        self._monitorThreads[monitorKey]['AttrList'].pop(self._monitorThreads[monitorKey]['AttrList'].index(argin))
                        self.set_change_event(argin,False,False)
                self._monitoredAttributeIds.pop(self._monitoredAttributeIds.index(attrId))
                #manage the property
                try:
                    self.MonitoredAttributes = self.__popPropertyElement('MonitoredAttributes',argin)
                except Exception,e:
                    self.error_stream("In %s.RemoveMonitoring(%s) cannot remove "\
                                      "from the property: %s"%
                                      (self.get_name(),argin,e))
                    raise e
                self.rebuildStatus()
        except Exception,e:
            self.error_stream("In %s.RemoveMonitoring(%s) exception: %s"%
                              (self.get_name(),argin,e))
            raise e
        #----- PROTECTED REGION END -----#	//	Skippy.RemoveMonitoring
        
#------------------------------------------------------------------
#    Is RemoveMonitoring command allowed
#------------------------------------------------------------------
    def is_RemoveMonitoring_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_RemoveMonitoring_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
#------------------------------------------------------------------
#    SetMonitoringPeriod command:
#------------------------------------------------------------------
    def SetMonitoringPeriod(self, argin):
        """ From the list of already monitored attributes, stablish (or change) the period that it is checked.
        
        :param argin: 
        :type: PyTango.DevVarStringArray
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".SetMonitoringPeriod()")
        #----- PROTECTED REGION ID(Skippy.SetMonitoringPeriod) ENABLED START -----#
        try:
            if not len(argin) == 2:
                raise AttributeError("Invalid arguments, use [attrName,AttrPeriod]")
            else:
                if argin[0].count("'") == 2:
                    attrName = str(argin[0].split("'")[1])
                else:
                    attrName = argin[0]
                if argin[1].count("'") == 2:
                    attrPeriod = float(argin[1].split("'")[1])
                else:
                    attrPeriod = float(argin[1])
                self.info_stream("In %s.SetMonitoringPeriod(%s,%f)"
                                 %(self.get_name(),attrName,attrPeriod))
            multiattr = self.get_device_attr()
            attrId = multiattr.get_attr_ind_by_name(attrName)
            if not attrName in self.attributes.keys():
                raise AttributeError("No attribute named %s"%(attrName))
            elif not attrId in self._monitoredAttributeIds:
                raise AttributeError("Attribute %s is not monitored"%(attrName))
            elif attrPeriod < 0:
                raise AttributeError("Invalid period %f"%(attrPeriod))
            else:
                #Remove from the monitor where it already is:
                for monitorKey in self._monitorThreads.keys():
                    if self._monitorThreads[monitorKey]['AttrList'].count(attrName):
                        self._monitorThreads[monitorKey]['AttrList'].pop(self._monitorThreads[monitorKey]['AttrList'].index(attrName))
                        self.MonitoredAttributes = self.__popPropertyElement('MonitoredAttributes',attrName)
                #distinguish if the command should send it to the generic or not
                monitorTag = str(attrPeriod)
                if attrPeriod == 0: monitorTag = 'Generic'
                else: monitorTag = str(attrPeriod)
                #if there is a thread with this tag use it
                if self._monitorThreads.has_key(str(attrPeriod)):
                    self._monitorThreads[monitorTag]['AttrList'].append(attrName)
                #if not, then build it and start it.
                else:
                    self._monitorThreads[monitorTag] = self.__builtMonitorThread(monitorTag,attrPeriod)
                    self._monitorThreads[monitorTag]['AttrList'].append(attrName)
                    if self.get_state() == PyTango.DevState.RUNNING:
                        self._monitorThreads[monitorTag]['Thread'] = threading.Thread(target=self.__monitor,
                                                                                      args=([self._monitorThreads[monitorTag]]))
                        self._monitorThreads[monitorTag]['Event'].clear()
                        self._monitorThreads[monitorTag]['Thread'].setDaemon(True)
                        self._monitorThreads[monitorTag]['Thread'].start()
                if attrPeriod == 0:
                    self.MonitoredAttributes = self.__appendPropertyElement(\
                        'MonitoredAttributes',"%s"%(attrName))
                else:
                    self.MonitoredAttributes = self.__appendPropertyElement(\
                        'MonitoredAttributes',"%s:%6.3f"%(attrName,attrPeriod))
        except Exception,e:
            self.error_stream("In %s.SetMonitoringPeriod(%s) exception: %s"%
                              (self.get_name(),argin,e))
            raise e
        #----- PROTECTED REGION END -----#	//	Skippy.SetMonitoringPeriod
        
#------------------------------------------------------------------
#    Is SetMonitoringPeriod command allowed
#------------------------------------------------------------------
    def is_SetMonitoringPeriod_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_SetMonitoringPeriod_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
#------------------------------------------------------------------
#    GetMonitoringPeriod command:
#------------------------------------------------------------------
    def GetMonitoringPeriod(self, argin):
        """ Get the period that is checked an attribute monitored.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevFloat """
        self.debug_stream("In " + self.get_name() +  ".GetMonitoringPeriod()")
        argout = 0.0
        #----- PROTECTED REGION ID(Skippy.GetMonitoringPeriod) ENABLED START -----#
        try:
            attrName = argin
            multiattr = self.get_device_attr()
            attrId = multiattr.get_attr_ind_by_name(attrName)
            if not attrName in self.attributes.keys():
                raise AttributeError("No attribute named %s"%(attrName))
            elif not attrId in self._monitoredAttributeIds:
                raise AttributeError("Attribute %s is not monitored"%(attrName))
            for monitorKey in self._monitorThreads.keys():
                if self._monitorThreads[monitorKey]['AttrList'].count(argin):
                    if monitorKey == 'Generic':
                        argout = self.attr_TimeStampsThreshold_read
                    else:
                        argout = float(monitorKey)
        except Exception,e:
            self.error_stream("In %s.GetMonitoringPeriod(%s) exception: %s"%
                              (self.get_name(),argin,e))
            raise e
        #----- PROTECTED REGION END -----#	//	Skippy.GetMonitoringPeriod
        return argout
        
#------------------------------------------------------------------
#    Is GetMonitoringPeriod command allowed
#------------------------------------------------------------------
    def is_GetMonitoringPeriod_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_GetMonitoringPeriod_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
#------------------------------------------------------------------
#    CMD command:
#------------------------------------------------------------------
    def CMD(self, argin):
        """ Expert command for a direct send of a SCPI command and read the answer.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In " + self.get_name() +  ".CMD()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.CMD) ENABLED START -----#
        argin = str(argin)
        self.info_stream("In %s.CMD(\"%s\")"%(self.get_name(),argin))
        try:
            if argin.find('?') >= 0:
                argout = self._instrument.ask(argin)
            else:
                self._instrument.write(argin)
                argout = ""
            self.info_stream("In %s.CMD(): %s"%(self.get_name(),argout))
        except Exception,e:
            self.error_stream("In %s.CMD() Exception: %s"%(self.get_name(),e))
            argout = ""
            self.__reconnectInstrumentObj()
        #----- PROTECTED REGION END -----#	//	Skippy.CMD
        return argout
        
#------------------------------------------------------------------
#    Is CMD command allowed
#------------------------------------------------------------------
    def is_CMD_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_CMD_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
#------------------------------------------------------------------
#    CMDfloat command:
#------------------------------------------------------------------
    def CMDfloat(self, argin):
        """ Expert command for a direct send of a SCPI command and read the answer converted to a float list.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevVarFloatArray """
        self.debug_stream("In " + self.get_name() +  ".CMDfloat()")
        argout = [0.0]
        #----- PROTECTED REGION ID(Skippy.CMDfloat) ENABLED START -----#
        argin = str(argin)
        self.info_stream("In %s::CMDfloat(\"%s\")"%(self.get_name(),argin))
        try:
            if argin.find('?') >= 0:
                argout = self._instrument.ask_for_values(argin)
            else:
                self._instrument.write(argin)
                argout = float("NaN")
            self.info_stream("In %s.CMDfloat(): %s"%(self.get_name(),repr(argout)))
        except Exception,e:
            self.error_stream("In %s.CMDfloat() Exception: %s"%(self.get_name(),e))
            argout = ""
            self.__reconnectInstrumentObj()
        #----- PROTECTED REGION END -----#	//	Skippy.CMDfloat
        return argout
        
#------------------------------------------------------------------
#    Is CMDfloat command allowed
#------------------------------------------------------------------
    def is_CMDfloat_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_CMDfloat_allowed()")
        return not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
#------------------------------------------------------------------
#    Standby command:
#------------------------------------------------------------------
    def Standby(self):
        """ Stablish communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Standby()")
        #----- PROTECTED REGION ID(Skippy.Standby) ENABLED START -----#
        if self.get_state() == PyTango.DevState.OFF:
            if self.__connectInstrumentObj():
                self.change_state(PyTango.DevState.STANDBY)
        elif self.get_state() == PyTango.DevState.ON:
            self.__unbuilder()
        #----- PROTECTED REGION END -----#	//	Skippy.Standby
        
#------------------------------------------------------------------
#    Is Standby command allowed
#------------------------------------------------------------------
    def is_Standby_allowed(self):
        self.debug_stream("In " + self.get_name() + ".is_Standby_allowed()")
        return not(self.get_state() in [PyTango.DevState.RUNNING,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.STANDBY])

#==================================================================
#
#    SkippyClass class definition
#
#==================================================================
class SkippyClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'Instrument':
            [PyTango.DevString,
            "The name of the instrument to use",
            [] ],
        'Port':
            [PyTango.DevUShort,
            "In case of socket interface the port value can be changed",
            [5025]],
        'NumChannels':
            [PyTango.DevUShort,
            "Number of channels available in the instrument, if it has",
            [0]],
        'NumFunctions':
            [PyTango.DevUShort,
            "Number of functions available in the instrument, if it has",
            [0]],
        'MonitoredAttributes':
            [PyTango.DevVarStringArray,
            "When the device is in RUNNING state, the attributes listed here will be monitored (having events) with a period said in the attribute TimeStampsThreashold (or different if specified with a : separator after the attrName)",
            [] ],
        'AutoOn':
            [PyTango.DevBoolean,
            "When device startup, try an on() to connect to the instrument authomatically",
            [True]],
        'AutoStart':
            [PyTango.DevBoolean,
            "When device startup, try an Start() to monitor attributes, if MonitoredAttributes is configuredc, authomatically",
            [True]],
        'AutoStandby':
            [PyTango.DevBoolean,
            "When device startup, try an standby() to connect to the instrument authomatically.",
            [True]],
        }


    #    Command definitions
    cmd_list = {
        'IDN':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevString, "none"]],
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'On':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Off':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Exec':
            [[PyTango.DevString, "none"],
            [PyTango.DevString, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'AddMonitoring':
            [[PyTango.DevString, "none"],
            [PyTango.DevVoid, "none"]],
        'RemoveMonitoring':
            [[PyTango.DevString, "none"],
            [PyTango.DevVoid, "none"]],
        'SetMonitoringPeriod':
            [[PyTango.DevVarStringArray, "none"],
            [PyTango.DevVoid, "none"]],
        'GetMonitoringPeriod':
            [[PyTango.DevString, "none"],
            [PyTango.DevFloat, "none"]],
        'CMD':
            [[PyTango.DevString, "none"],
            [PyTango.DevString, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'CMDfloat':
            [[PyTango.DevString, "none"],
            [PyTango.DevVarFloatArray, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'Standby':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        }


    #    Attribute definitions
    attr_list = {
        'Idn':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description': "Instrument identification",
            } ],
        'QueryWindow':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Query Window",
                'unit': "queries",
                'format': "%2d",
                'min value': "1",
                'max warning': "20",
                'description': "When many attributes are requested at the same time, they are grouped in subqueries of this size",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'TimeStampsThreshold':
            [[PyTango.DevFloat,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Time stamps threshold",
                'unit': "seconds",
                'format': "%3.2g",
                'max value': "3",
                'min value': "0.1",
                'description': "This value sets the threshold time to use a cached value or hardware read it",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        }


#------------------------------------------------------------------
#    SkippyClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In Skippy Class  constructor"

#==================================================================
#
#    Skippy class main method
#
#==================================================================
def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(SkippyClass,Skippy,'Skippy')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
