#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        Skippy.py
## 
## Project :     SCPI
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Standard Commands for Programmable Instruments (SCPI) DeviceServer """

__all__ = ["Skippy", "SkippyClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(Skippy.additionnal_import) ENABLED START -----#
import socket
import threading
import time
import traceback
import communicator
import instructionSet
import numpy,struct
from types import StringType
#----- PROTECTED REGION END -----#	//	Skippy.additionnal_import

##############################################################################
## Device States Description
##
## OFF : No connection stablished with the instrument.
## ON : Connection stablished with the instrument.
## RUNNING : Connection stablished and active monitoring.
## ALARM : Reported errors from the instrument.
## FAULT : Communication error with the instrument.
## INIT : Initialization stage.
##############################################################################

class Skippy (PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------
#----- PROTECTED REGION ID(Skippy.global_variables) ENABLED START -----#

    ######
    #----- section to resolve instrument property
    def __buildInstrumentObj(self):
        try:
            self.__instrument = self.__getConnectionObj(self.Instrument)
        except SyntaxError,e:
            self.error_stream("Error in the instrument name: %s"%(e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("%s: review the instrument property"%(e))
            return False
        except Exception,e:
            self.error_stream("Generic exception: %s"%(e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("initialisation exception: %s"%(e))
            return False
        self.change_state(PyTango.DevState.OFF)
        return True
    
    def __connectInstrumentObj(self):
        try:
            self.__instrument.connect()
            self.__idn = self.__instrument.ask("*IDN?")
        except Exception,e:
            self.error_stream("Cannot connect to the instrument due to: %s"%e)
            return False
        else:
            self.info_stream("Connected to the instrument and "\
                             "identified as: %s"%(repr(self.__idn)))
            self.change_state(PyTango.DevState.ON)
            return True
    
    def __getConnectionObj(self,instrumentName):
        if self.__isHostName(instrumentName):
            return communicator.bySocket(instrumentName,port=self.Port,parent=self)
        elif self.__isTangoName(instrumentName):
            if self.__isVisaDevice(instrumentName):
                return communicator.byVisa(instrumentName,parent=self)
            raise SyntaxError("Instrument device type not identified")
        raise SyntaxError("Instrument name not identified")
    
    def __isHostName(self,name):
        try:
            socket.gethostbyname(name)
            self.debug_stream("Recognised the instrument %s as a host name"
                              %(name))
            return True
        except:
            self.debug_stream("Not possible to resolve %s in the network"
                              %(name))
            return False
    
    def __isTangoName(self,name):
        try:
            PyTango.DeviceProxy(name)
            self.debug_stream("Recognised the instrument %s as a tango device"
                              %(name))
            return True
        except:
            self.debug_stream("Not possible to have a proxy to something "\
                              "called %s"%(name))
            return False

    def __isVisaDevice(self,devName):
        try:
            devClass = PyTango.DeviceProxy(devName).info().dev_class
            if devClass == 'PyVisa':
                self.debug_stream("Device %s is a recognised PyVisa"%(devName))
                return True
            else:
                self.debug_stream("Device %s has %s class"%(devName,devClass))
                return False
        except:
            self.debug_stream("Unable to get the class of the device %s"
                              %(devName))
            return False
    #----- done section to resolve instrument property
    ######
    
    ######
    #----- dynamic attributes builder section
    def builder(self):
        try:
            instructionSet.identifier(self.__idn,self)
        except Exception,e:
            msg = "identification error: %s (*IDN?:%s)"%(e,repr(self.__idn))
            self.error_stream("%s %s"%(self.get_name(),msg))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg(msg)
        
    def unbuilder(self):
        pass #TODO: remove all the dynamic attributes from the current builded.
    
    def __filterAttributes(self,multiattr,data):
        '''Avoid hardware readings of:
           - attributes that are internals to the device
           - attributes that reading is recent (TODO)
        '''
        try:
            t = time.time()
            delta_t = self.attr_TimeStampsThreshold_read
            scalar = []
            spectrum = []
            image = []
            for attr_index in data:
                attrObj = multiattr.get_attr_by_ind(attr_index)
                attrName = attrObj.get_name()
                if not self.attributes.has_key(attrName):
                        self.debug_stream("In %s.__filterAttributes() "\
                                          "excluding %s: is not a hw attr."
                                          %(self.get_name(),attrName))
                else:
                    t_a = self.attributes[attrName]['timestamp']
                    if not t_a == None and t - t_a < delta_t:
                        self.debug_stream("In %s.__filterAttributes() "\
                                          "excluding %s: t < delta_t"
                                          %(self.get_name(),attrName))
                    else:
                        if attrObj.get_data_format() == PyTango.AttrDataFormat.SCALAR:
                            scalar.append(attrName)
                        elif attrObj.get_data_format() == PyTango.AttrDataFormat.SPECTRUM:
                            spectrum.append(attrName)
                            #when an spectrum are required, some reference attributes will be needed
                            if self.attributes.has_key('WaveformDataFormat'):
                                scalar.append('WaveformDataFormat')
                            if self.attributes.has_key('WaveformOrigin'):
                                scalar.append('WaveformOrigin')
                            if self.attributes.has_key('WaveformIncrement'):
                                scalar.append('WaveformIncrement')
                        elif attrObj.get_data_format() == PyTango.AttrDataFormat.IMAGE:
                            image.append(attrName)
                        else:
                            self.error_stream("In %s.__filterAttributes() "\
                                              "unknown data format for "\
                                              "attribute %s"%(self.get_name(),attrName))
            self.debug_stream("In %s.__filterAttributes() scalar list: %s; "\
                              "spectrum list: %s; image list: %s"
                              %(self.get_name(),scalar,spectrum,image))
            #Remove repeated attributes
            for attr in scalar:
                while scalar.count(attr) > 1:
                    scalar.pop(scalar.index(attr))
            for attr in spectrum:
                while spectrum.count(attr) > 1:
                    spectrum.pop(spectrum.index(attr))
            for attr in image:
                while image.count(attr) > 1:
                    image.pop(image.index(attr))
            return scalar,spectrum,image
        except Exception,e:
            self.error_stream("In %s.__filterAttributes(%s) Exception: %s"
                              %(self.get_name(),data,e))
            traceback.print_exc()
            return None
    
    def __preHardwareRead(self,attrList,window=1):
        '''Given a list of attributes to be read, prepare it.
           - Divide the attributes to be read in subsets of QueryWindow size.
           - Build the concatenations of queries per subset.
           Example: QueryWindow = 4
           Input: attrList = [a1,a2,a3,a4,a5,a6,a7,a8,a9,a10]
           Output: subsetsIndexes = [[a1,a2,a3,a4],
                                     [a5,a6,a7,a8],
                                     [a9,a10]]
                   subsetsQueries = ["cmd;cmd;cmd;cmd;",
                                     "cmd;cmd;cmd;cmd;",
                                     "cmd;cmd;"]
        '''
        try:
            self.debug_stream("In %s.__preHardwareRead()"%self.get_name())
            subsetsIndexes = []
            subsetsQueries = []
            for i in range(0,len(attrList),window):
                subsetsIndexes.append(attrList[i:i+window])
                subsetsQueries.append("")
                for j in range(len(subsetsIndexes[len(subsetsIndexes)-1])):
                    attrName = subsetsIndexes[len(subsetsIndexes)-1][j]
                    attrCmd = self.attributes[attrName]['readStr']
                    subsetsQueries[len(subsetsQueries)-1] = "%s%s;"%(subsetsQueries[len(subsetsQueries)-1],attrCmd)
            return subsetsIndexes,subsetsQueries
        except Exception,e:
            self.error_stream("In %s.__preHardwareRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
            return None,None

    def __hardwareRead(self,query):
        '''Given a string with a ';' separated list of scpi commands 'ask'
           to the instrument and return what the instrument responds.
        '''
        self.debug_stream("In %s.__hardwareRead()"%self.get_name())
        return self.__instrument.ask(query)

    def __postHardwareScalarRead(self,indexes,answers):
        '''Given the answers organise them in the self.attributes dictionary.
           Example: QueryWindow = 4
           Input: indexes = [[a1,a2,a3,a4],
                             [a5,a6,a7,a8],
                             [a9,a10]]
                  answers = ["ans;ans;ans;ans;",
                             "ans;ans;ans;ans;",
                             "ans;ans;"]
        '''
        self.debug_stream("In %s.__postHardwareScalarRead()"%self.get_name())
        t = time.time()
        try:
            attrWithEvents = []
            for i,answer in enumerate(answers):
                for j,value in enumerate(answer.split('\n')[0].split(';')):
                    attrName = indexes[i][j]
                    try:
                        if self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevBoolean]:
                            self.attributes[attrName]['lastReadValue'] = bool(int(value))
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevUChar,
                                                                   PyTango.CmdArgType.DevUShort,
                                                                   PyTango.CmdArgType.DevShort,
                                                                   PyTango.CmdArgType.DevULong,
                                                                   PyTango.CmdArgType.DevLong,
                                                                   PyTango.CmdArgType.DevULong64,
                                                                   PyTango.CmdArgType.DevLong64]:
                            self.attributes[attrName]['lastReadValue'] = int(value)
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevFloat,
                                                                   PyTango.CmdArgType.DevDouble]:
                            if value == '9.99999E+37':#this is the instrument tag for non measurable
                                self.attributes[attrName]['lastReadValue'] = float('NaN')
                            else:
                                self.attributes[attrName]['lastReadValue'] = float(value)
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevString]:
                            self.attributes[attrName]['lastReadValue'] = str(value)
                        else:
                            self.warn_stream("In %s.__postHardwareScalarRead() "\
                                             "Unrecognized data type for %s"
                                             %(self.get_name(),attrName))
                            self.attributes[attrName]['lastReadValue'] = value
                    except Exception,e:
                        self.error_stream("In %s.__postHardwareScalarRead() "\
                                          "Exception of attribute %s: %s"
                                          %(self.get_name(),attrName,e))
                        self.attributes[attrName]['lastReadValue'] = None
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_INVALID
                    else:
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                    finally:
                        self.attributes[attrName]['timestamp'] = t
                        if attrName in self.__monitoredAttr['Special'].keys() or\
                           attrName in self.__monitoredAttr['Normal']:
                            attrWithEvents.append([attrName,
                                                   self.attributes[attrName]['lastReadValue'],
                                                   self.attributes[attrName]['quality']
                                                 ])
            self.debug_stream("to fire events: %s"%(repr(attrWithEvents)))
            self.fireEventsList(attrWithEvents)
        except Exception,e:
            self.error_stream("In %s.__postHardwareScalarRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
    
    def __postHardwareSpectrumRead(self,indexes,answers):
        '''Given the answers organise them in the self.attributes dictionary.
           QueryWindow doesn't apply here, the spectrums are made in separated reads
           Input: indexes = [[s1],
                             [s2],
                             [a3]]
                  answers = ["f1,f2,f3,f4,...,fn",
                             "f1,f2,f3,f4,...,fn",,
                             "f1,f2,f3,f4,...,fn",]
           A waveform has always a first character '#'
           The second is a char with the number of elements in the next variable field
           The third, represented with Rs, are the number of elements in the waveform that comes next.
           Example: answer = #532017... means, 5 elements will be in the second
                    field, and there will be 32017 elements in the third.
        '''
        self.debug_stream("In %s.__postHardwareSpectrumRead()"%self.get_name())
        t = time.time()
        try:
            attrWithEvents = []
            for i,answer in enumerate(answers):
                attrName = indexes[i][0]
                if self.attributes.has_key('WaveformDataFormat') and \
                   self.attributes.has_key('WaveformOrigin') and \
                   self.attributes.has_key('WaveformIncrement'):
                    dataFormat = self.attributes['WaveformDataFormat']['lastReadValue']
                    if dataFormat.startswith('ASC'):
                        self.debug_stream("Spectrum received in ascii: %s"%(repr(answer)[:100]))
                        self.attributes[attrName]['lastReadValue'] = numpy.fromstring(answer,dtype=float,sep=',')
                        self.attributes[attrName]['timestamp'] = t
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                    else:
                        self.debug_stream("Spectrum received in binary: %s...%s"
                                          %(repr(answer[:45]),repr(answer[len(answer)-45:])))
                        #process the header
                        if not answer[0] == '#':
                            self.error_stream("Wrong data receiver for the "\
                                              "attribute %s"%attrName)
                        nBytesLengthBlock = int(answer[1])
                        nBytesWaveBlock = int(answer[2:nBytesLengthBlock+2])
                        waveBytes = answer[nBytesLengthBlock+2:nBytesWaveBlock]
                        self.debug_stream("In %s.__postHardwareSpectrumRead() "\
                                          "waveform data: header size %d bytes, "\
                                          "wave size %d bytes"
                                          %(self.get_name(),nBytesLengthBlock,nBytesWaveBlock))
                        if dataFormat.startswith('BYT'):
                            format = 'b'#signed char, 1byte
                            divisor = 1
                        elif dataFormat.startswith('WORD'):
                            format = 'h'#signed short, 2byte
                            divisor = 2
#                             elif dataFormat.startswith('LON'):
#                                 pass
                        else:
                            self.error_stream("Cannot decodify data receiver "\
                                              "for the attribute %s"%attrName)
                            self.attributes[attrName]['lastReadValue'] = []
                            self.attributes[attrName]['timestamp'] = t
                            self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_INVALID
                        nCompletBytes = len(waveBytes)-(len(waveBytes)%divisor)
                        if not len(waveBytes)%4 == 0:
                            self.debug_stream("nIncompleteBytes = %d"%(len(waveBytes)%divisor))
                        #convert the received input to integers
                        unpackInt = struct.unpack(format*(nCompletBytes/divisor),waveBytes[:nCompletBytes])
                        #expand the input when each float is codified in less than 4 bytes
                        floats = numpy.array(unpackInt,dtype=float)
                        waveorigin = self.attributes['WaveformOrigin']['lastReadValue']
                        waveincrement = self.attributes['WaveformIncrement']['lastReadValue']
                        self.attributes[attrName]['lastReadValue'] = (waveorigin + (waveincrement * floats))
                        self.attributes[attrName]['timestamp'] = t
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                else:
                    self.warn_stream("In %s.__postHardwareSpectrumRead() "\
                                     "Unrecognised spectrum attribute, "\
                                     "storing raw data"%(self.get_name()))
                    self.attributes[attrName]['lastReadValue'] = answer
                    self.attributes[attrName]['timestamp'] = t
                    self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                if attrName in self.__monitoredAttr['Special'].keys() or\
                   attrName in self.__monitoredAttr['Normal']:
                    attrWithEvents.append([
                                           attrName,
                                           self.attributes[attrName]['lastReadValue'],
                                           self.attributes[attrName]['quality']
                                         ])
            self.debug_stream("to fire events: %s"%(repr(attrWithEvents)))
            self.fireEventsList(attrWithEvents)
        except Exception,e:
            self.error_stream("In %s.__postHardwareSpectrumRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
    
    @instructionSet.AttrExc
    def read_attr(self, attr):
        attrName = attr.get_name()
        self.debug_stream("read_attr for %s"%(attrName))
        if self.attributes.has_key(attrName):
            value = self.attributes[attrName]['lastReadValue']
            timestamp = self.attributes[attrName]['timestamp']
            quality = self.attributes[attrName]['quality']
            if self.attributes[attrName]['dim'] == 0:
                if value == None:
                    attr.set_value_date_quality(value,time.time(),PyTango.AttrQuality.ATTR_INVALID)
                else:
                    attr.set_value_date_quality(value,timestamp,quality)
            elif self.attributes[attrName]['dim'] == 1:
                if value == None:
                    attr.set_value_date_quality(value,time.time(),PyTango.AttrQuality.ATTR_INVALID,1)
                else:
                    attr.set_value_date_quality(value,timestamp,quality,len(value))
        elif attrName.endswith("Step"):
            parentAttrName = attrName.split('Step')[0]
            print parentAttrName
            value = self.attributes[parentAttrName]['rampStep']
            print self.attributes[parentAttrName]
            if value == None:
                attr.set_value_date_quality(0,time.time(),PyTango.AttrQuality.ATTR_INVALID)
            else:
                attr.set_value(value)
        elif attrName.endswith("StepSpeed"):
            parentAttrName = attrName.split('StepSpeed')[0]
            print parentAttrName
            value = self.attributes[parentAttrName]['rampStepSpeed']
            print self.attributes[parentAttrName]
            if value == None:
                attr.set_value_date_quality(0,time.time(),PyTango.AttrQuality.ATTR_INVALID)
            else:
                attr.set_value(value)
        else:
            raise AttributeError("Invalid read of the attribute %s"
                                 %(attrName))

    @instructionSet.AttrExc
    def write_attr(self, attr):
        '''The execution of this method starts with three different branches:
           - An instrument attribute to be send. This splits in two branches also:
             - Direct write
             - Launch a thread (if not yet) to drive a ramp to the setpoint
           - The other two are the internal ramp attributes
           - Other case, raise an exception
        '''
        attrName = attr.get_name()
        data = []
        attr.get_write_value(data)
        if self.attributes.has_key(attrName):
            self.__write_instrument_attr(attr,attrName,data)
        elif attrName.endswith("Step"):
            parentAttrName = attrName.split('Step')[0]
            self.attributes[parentAttrName]['rampStep'] = data[0]
        elif attrName.endswith("StepSpeed"):
            parentAttrName = attrName.split('StepSpeed')[0]
            self.attributes[parentAttrName]['rampStepSpeed'] = data[0]
        else:
            raise AttributeError("Invalid write of the attribute %s"
                                 %(attrName))

    def __write_instrument_attr(self,attr,attrName,data):
        self.attributes[attrName]['lastWriteValue'] = data[0]
        #Normal case, non rampable attribute
        if not self.attributes[attrName].has_key('rampThread'):
            cmd = self.attributes[attrName]['writeStr'](data[0])
            #filter the write value if the attribute was configured this way
            if self.attributes[attrName].has_key('writeValues') and \
               not data[0].upper() in self.attributes[attrName]['writeValues']:
                self.error_stream("In %s.__write_instrument_attr() avoid to send: %s"
                                  %(self.get_name(),cmd))
                raise AttributeError("Invalid write value %s of the attribute %s"
                                     %(repr(data[0]),attrName))
            else:
                self.debug_stream("In %s.__write_instrument_attr() sending: %s"
                                  %(self.get_name(),cmd))
                self.__instrument.write(cmd)
        else:
            #rampeable but invalid ramp
            if not self.attributes[attrName]['rampStep'] in [None,0.0] or \
               not self.attributes[attrName]['rampStepSpeed'] in [None,0.0]:
                cmd = self.attributes[attrName]['writeStr'](data[0])
                self.debug_stream("In %s.__write_instrument_attr() sending: %s"
                                  %(self.get_name(),cmd))
                self.__instrument.write(cmd)
            else:
                #rampeable and create a thread, if it doesn't exist
                if self.attributes[attrName]['rampThread'] == None:
                    self.attributes[attrName]['rampThread'] = threading.Thread(target=self.rampStepper,
                                                                               args=([attrName]))
                    self.attributes[attrName]['rampThread'].setDaemon(True)
                    self.attributes[attrName]['rampThread'].start()
                #no else need because during the ramp the it goes to 
                #'lastWriteValue' and it has been already updated.

    def rampStepper(self,attrName):
        #Remember the arguments when this is called as thread target, is a tuple
        # and the content of this tuple is a list with one string element.
        self.debug_stream("In %s.rampStepper(%s)"%(self.get_name(),attrName))
        #prepare
        backup_state = self.get_state()
        self.change_state(PyTango.DevState.MOVING)
        attrReadCmd = self.attributes[attrName]['readStr']
        #move
        self.attributes[attrName]['lastReadValue'] = float(self.__instrument.ask(attrReadCmd))
        current_pos = self.attributes[attrName]['lastReadValue']
        self.info_stream("In %s.rampSteeper(): started the movement from %f"
                         %(self.get_name(),current_pos))
        while not current_pos == self.attributes[attrName]['lastWriteValue']:
            if current_pos > self.attributes[attrName]['lastWriteValue']:
                if current_pos - self.attributes[attrName]['lastWriteValue'] < self.attributes[attrName]['rampStep']:
                    current_pos = self.attributes[attrName]['lastWriteValue']
                else: current_pos -= self.attributes[attrName]['rampStep']
            elif current_pos < self.attributes[attrName]['lastWriteValue']:
                if self.attributes[attrName]['lastWriteValue'] - current_pos < self.attributes[attrName]['rampStep']:
                    current_pos = self.attributes[attrName]['lastWriteValue']
                else: current_pos += self.attributes[attrName]['rampStep']
            attrWriteCmd = self.attributes[attrName]['writeStr'](current_pos)
            #self.debug_stream("In %s.write_attr() sending: %s"%(self.get_name(),attrWriteCmd))
            self.__instrument.write(attrWriteCmd)
            time.sleep(self.attributes[attrName]['rampStepSpeed'])
        self.info_stream("In %s.rampSteeper(): finished the movement at %f"
                         %(self.get_name(),current_pos))
        #close
        self.change_state(backup_state)
        self.attributes[attrName]['rampThread'] = None

    #----- done dynamic attributes builder section
    ######

    ######
    #----- event manager section
    def fireEventsList(self,eventsAttrList):
        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                self.debug_stream("In %s.fireEventsList() attribute: %s"%(self.get_name(),attrEvent[0]))
                if len(attrEvent) == 3:#specifies quality
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,PyTango.AttrQuality.ATTR_VALID)
            except Exception,e:
                self.error_stream("In %s.fireEventsList() Exception with attribute %s: %s"%(self.get_name(),attrEvent[0],e))
                traceback.print_exc()
    #@todo: clean the important logs when they loose importance.
    def change_state(self,newstate):
        self.debug_stream("In %s.change_state(%s)"%(self.get_name(),str(newstate)))
        if newstate != self.get_state():
            self.set_state(newstate)
            self.push_change_event('State',newstate)
    def cleanAllImportantLogs(self):
        self.debug_stream("In %s.cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")
    def addStatusMsg(self,current,important = False):
        self.debug_stream("In %s.addStatusMsg()"%self.get_name())
        msg = "The device is in %s state.\n"%(self.get_state())
        for ilog in self._important_logs:
            msg = "%s%s\n"%(msg,ilog)
        status = "%s%s"%(msg,current)
        self.set_status(status)
        self.push_change_event('Status',status)
        if important and not current in self._important_logs:
            self._important_logs.append(current)
    #----- done event manager section
    ######
    
    ######
    #----- attribute monitor section
    def _monitor(self):
        multiattr = self.get_device_attr()
        ###Prepare the monitorization
        self.change_state(PyTango.DevState.STANDBY)
        specialThreads = []
        for attrName in self.MonitoredAttributes:
            if attrName.count(':'):
                attrName,attrPeriod = attrName.split(':')
                if not attrName in self.attributes.keys():
                    self.error_stream("The %s is not an attribute in this device"
                                      %(attrName))
                elif attrName in self.__monitoredAttr['Special'].keys() or\
                   attrName in self.__monitoredAttr['Normal']:
                    self.error_stream("The attribute %s is configured to "\
                                      "monitor more than one time"%(attrName))
                else:
                    attrPeriod = float(attrPeriod)
                    attrId = multiattr.get_attr_ind_by_name(attrName)
                    self.debug_stream("Special monitoring for the attribute "\
                                      "%s with period %f"%(attrName,attrPeriod))
                    attrThread = threading.Thread(target=self._specialMonitor,
                                                  args=(attrName,attrPeriod,attrId))
                    self.__monitoredAttr['Special'][attrName] = {}
                    self.__monitoredAttr['Special'][attrName]['period'] = attrPeriod
                    self.__monitoredAttr['Special'][attrName]['Thread'] = attrThread
                    self.__monitoredAttr['Special'][attrName]['Event'] = threading.Event()
                    self.__monitoredAttr['Special'][attrName]['Event'].clear()
                    attrThread.setDaemon(True)
                    specialThreads.append(attrThread)
                    self.set_change_event(attrName,True,False)
            else:
                if not attrName in self.attributes.keys():
                    self.error_stream("The %s is not an attribute in this device"
                                      %(attrName))
                elif attrName in self.__monitoredAttr['Special'].keys() or\
                   attrName in self.__monitoredAttr['Normal']:
                    self.error_stream("The attribute %s is configured to "\
                                      "monitor more than one time"%(attrName))
                else:
                    self.debug_stream("Normal monitoring for the attribute %s"
                                      %(attrName))
                    attrId = multiattr.get_attr_ind_by_name(attrName)
                    self.__monitoredAttr['Normal'].append(attrName)
                    self.__monitoredAttr['NormalIDs'].append(attrId)
                    self.set_change_event(attrName,True,False)
        ### once is prepared launch all the special monitors and then enter in 
        #   the loop for the normals.
        for thread in specialThreads:
            thread.start()
        self.change_state(PyTango.DevState.RUNNING)
        self.addStatusMsg("Attributes to monitor: %s"
                          %(repr(self.MonitoredAttributes)),important=True)
        while not self.__monitorEvent.isSet():
            t0 = time.time()
            self.debug_stream("Monitoring normal attributes: %s"
                              %(repr(self.__monitoredAttr['Normal'])))
            self.read_attr_hardware(self.__monitoredAttr['NormalIDs'])
            #FIXME: it may depend on the attr time stamp
            tf = time.time()
            if tf-t0<self.attr_TimeStampsThreshold_read:
                time.sleep(self.attr_TimeStampsThreshold_read-(tf-t0))
            else:
                self.addStatusMsg("Normal monitoring required too much time")
        self.change_state(PyTango.DevState.STANDBY)
        for attrName in self.__monitoredAttr['Special'].keys():
            attrThread = self.__monitoredAttr['Special'][attrName]['Thread']
            while attrThread.is_alive():
                self.debug_stream("Waiting special monitor attribute %s to "\
                                  "finish"%(attrName))
                time.sleep(1)
        self.change_state(PyTango.DevState.ON)
        self.cleanAllImportantLogs()

    def _specialMonitor(self,attrName,attrPeriod,attrId):
        self.debug_stream("Special monitoring thread for the attribute %s "\
                          "starts"%(attrName))
        attrEvent = self.__monitoredAttr['Special'][attrName]['Event']
        while not self.__monitorEvent.isSet() and not attrEvent.isSet():
            t0 = time.time()
            self.debug_stream("Monitoring special attribute: %s (%f)"
                              %(attrName,attrPeriod))
            self.read_attr_hardware([attrId])
            tf = time.time()
            if tf-t0<attrPeriod:
                time.sleep(attrPeriod-(tf-t0))
            else:
                self.addStatusMsg("Special monitoring for %s required too "\
                                  "much time"%(attrName))
        self.debug_stream("Ending the special monitor for attribute %s"%(attrName))
        self.__monitoredAttr['Special'].pop(attrName)
        
    def __appendPropertyElement(self,propertyName,element):
        db = PyTango.Database()
        propertiesDict = db.get_device_property(self.get_name(),propertyName)
        propertiesDict[propertyName].append(element)
        db.put_device_property(self.get_name(),propertiesDict)
        return propertiesDict[propertyName]
    def __popPropertyElement(self,propertyName,element):
        db = PyTango.Database()
        propertiesDict = db.get_device_property(self.get_name(),propertyName)
        print propertiesDict
        propertyList = list(propertiesDict[propertyName])
        try:
            index = propertyList.index(element)
        except:
            #in case is an specially monitored, previous will throw an exception
            for name in propertyList:
                if name.startswith(element):
                    #find in the list something that starts with the attrName
                    #that continues with ':' and the period
                    index = propertyList.index(name)
                    break
        propertyList.pop(index)
        propertiesDict[propertyName] = propertyList
        print propertiesDict
        db.put_device_property(self.get_name(),propertiesDict)
        return propertiesDict[propertyName]
    #----- done attribute monitor section
    ######

#----- PROTECTED REGION END -----#	//	Skippy.global_variables
#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In " + self.get_name() + ".__init__()")
        Skippy.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.debug_stream("In " + self.get_name() + ".delete_device()")
        #----- PROTECTED REGION ID(Skippy.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.delete_device

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.debug_stream("In " + self.get_name() + ".init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Idn_read = ''
        self.attr_QueryWindow_read = 0
        self.attr_TimeStampsThreshold_read = 0.0
        #----- PROTECTED REGION ID(Skippy.init_device) ENABLED START -----#
        self.attr_QueryWindow_read = 1#Not allow 0
        #tools for the Exec() cmd
        DS_MODULE = __import__(self.__class__.__module__)
        kM = dir(DS_MODULE)
        vM = map(DS_MODULE.__getattribute__, kM)
        self.__globals = dict(zip(kM, vM))
        self.__globals['self'] = self
        self.__globals['module'] = DS_MODULE
        self.__locals = {}
        
        self.attributes={}
        self._important_logs = []
        self.set_state(PyTango.DevState.INIT)
        self.set_change_event('State',True,False)
        self.set_change_event('Status',True,False)
        self.get_device_properties(self.get_device_class())
        if not self.__buildInstrumentObj(): return
        if self.AutoOn:
            if self.__connectInstrumentObj():
                self.builder()
        self.__monitorThread = None
        self.__monitorEvent = threading.Event()
        self.__monitorEvent.clear()
        self.__monitoredAttr = {'Normal':[],
                                'NormalIDs':[],
                                'Special':{}}
        if self.AutoStart:
            self.Start()
        #----- PROTECTED REGION END -----#	//	Skippy.init_device

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.debug_stream("In " + self.get_name() + ".always_excuted_hook()")
        #----- PROTECTED REGION ID(Skippy.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.always_executed_hook

#==================================================================
#
#    Skippy read/write attribute methods
#
#==================================================================

#------------------------------------------------------------------
#    Read Idn attribute
#------------------------------------------------------------------
    def read_Idn(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_Idn()")
        #----- PROTECTED REGION ID(Skippy.Idn_read) ENABLED START -----#
        self.attr_Idn_read = self.__idn
        #----- PROTECTED REGION END -----#	//	Skippy.Idn_read
        attr.set_value(self.attr_Idn_read)
        
#------------------------------------------------------------------
#    Read QueryWindow attribute
#------------------------------------------------------------------
    def read_QueryWindow(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_QueryWindow()")
        #----- PROTECTED REGION ID(Skippy.QueryWindow_read) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.QueryWindow_read
        attr.set_value(self.attr_QueryWindow_read)
        
#------------------------------------------------------------------
#    Write QueryWindow attribute
#------------------------------------------------------------------
    def write_QueryWindow(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_QueryWindow()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(Skippy.QueryWindow_write) ENABLED START -----#
        self.attr_QueryWindow_read = int(data)
        #----- PROTECTED REGION END -----#	//	Skippy.QueryWindow_write
        
#------------------------------------------------------------------
#    Read TimeStampsThreshold attribute
#------------------------------------------------------------------
    def read_TimeStampsThreshold(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_TimeStampsThreshold()")
        #----- PROTECTED REGION ID(Skippy.TimeStampsThreshold_read) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.TimeStampsThreshold_read
        attr.set_value(self.attr_TimeStampsThreshold_read)
        
#------------------------------------------------------------------
#    Write TimeStampsThreshold attribute
#------------------------------------------------------------------
    def write_TimeStampsThreshold(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_TimeStampsThreshold()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(Skippy.TimeStampsThreshold_write) ENABLED START -----#
        self.attr_TimeStampsThreshold_read = float(data)
        #----- PROTECTED REGION END -----#	//	Skippy.TimeStampsThreshold_write
        



#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self, data):
        self.debug_stream("In " + self.get_name() + ".read_attr_hardware()")
        #----- PROTECTED REGION ID(Skippy.read_attr_hardware) ENABLED START -----#
        try:
            multiattr = self.get_device_attr()
            scalarList,spectrumList,imageList = self.__filterAttributes(multiattr, data)
            if not len(scalarList) == 0:
                indexes,queries = self.__preHardwareRead(scalarList,self.attr_QueryWindow_read)
                answers = []
                for query in queries:
                    answers.append(self.__hardwareRead(query))
                self.debug_stream("In %s.read_attr_hardware() scalar answers: %s"\
                                  %(self.get_name(),answers))
                self.__postHardwareScalarRead(indexes,answers)
            if not len(spectrumList) == 0:
                indexes,queries = self.__preHardwareRead(spectrumList,1)
                answers = []
                for query in queries:
                    answers.append(self.__hardwareRead(query))
                self.debug_stream("In %s.read_attr_hardware() spectrum answers number: %s"\
                                  %(self.get_name(),len(answers)))
                self.__postHardwareSpectrumRead(indexes,answers)
            if not len(imageList) == 0:
                self.error_stream("Excluding 2 dimensional attributes")
        except Exception,e:
            self.error_stream("In %s.read_attr_hardware() Exception: %s"\
                              %(self.get_name(),e))
            try:
                self.__instrument.disconnect()
            except Excpetion,e:
                self.error_stream("In %s.read_attr_hardware() Cannot disconnect: %s"\
                                  %(self.get_name(),e))
            self.__buildInstrumentObj()
            self.__connectInstrumentObj()
        #----- PROTECTED REGION END -----#	//	Skippy.read_attr_hardware


#==================================================================
#
#    Skippy command methods
#
#==================================================================

#------------------------------------------------------------------
#    IDN command:
#------------------------------------------------------------------
    def IDN(self):
        """ Request identification to the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In " + self.get_name() +  ".IDN()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.IDN) ENABLED START -----#
        self.__idn = self.__instrument.ask("*IDN?")
        argout = self.__idn
        #----- PROTECTED REGION END -----#	//	Skippy.IDN
        return argout
        
#------------------------------------------------------------------
#    Start command:
#------------------------------------------------------------------
    def Start(self):
        """ Start an active monitoring.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Start()")
        #----- PROTECTED REGION ID(Skippy.Start) ENABLED START -----#
        if self.__monitorThread == None:
            self.__monitorThread = threading.Thread(target=self._monitor)
            self.__monitorThread.setDaemon(True)
            self.__monitorThread.start()
        #----- PROTECTED REGION END -----#	//	Skippy.Start
        
#------------------------------------------------------------------
#    Stop command:
#------------------------------------------------------------------
    def Stop(self):
        """ Stop the active monitoring.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Stop()")
        #----- PROTECTED REGION ID(Skippy.Stop) ENABLED START -----#
        self.__monitorEvent.set()
        #----- PROTECTED REGION END -----#	//	Skippy.Stop
        
#------------------------------------------------------------------
#    On command:
#------------------------------------------------------------------
    def On(self):
        """ Stablish communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".On()")
        #----- PROTECTED REGION ID(Skippy.On) ENABLED START -----#
        try:
            self.__instrument.connect()
        except Exception,e:
            msg = "Cannot connect to the instrument due to: %s"%e
            self.error_stream(msg)
            self.addStatusMsg(msg)
            self.change_state(PyTango.DevState.FAULT)
        else:
            self.__idn = self.__instrument.ask("*IDN?")
            self.info_stream("Connected to the instrument and "\
                             "identified as: %s"%(repr(self.__idn)))
            self.change_state(PyTango.DevState.ON)
            self.builder()
        #----- PROTECTED REGION END -----#	//	Skippy.On
        
#------------------------------------------------------------------
#    Off command:
#------------------------------------------------------------------
    def Off(self):
        """ Release the communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Off()")
        #----- PROTECTED REGION ID(Skippy.Off) ENABLED START -----#
        try:
            self.__instrument.close()
        except:
            self.error_stream("Cannot disconnect from the instrument")
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Off command failed")
        else:
            self.__idn = ""
            self.info_stream("disconnected to the instrument %s"
                             %(self.Instrument))
            self.change_state(PyTango.DevState.OFF)
            self.unbuilder()
        #----- PROTECTED REGION END -----#	//	Skippy.Off
        
#------------------------------------------------------------------
#    Exec command:
#------------------------------------------------------------------
    def Exec(self, argin):
        """ evaluate python code inside the device server. This command can be very helpful and dangerous.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In " + self.get_name() +  ".Exec()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.Exec) ENABLED START -----#
        try:
            try:
                # interpretation as expression
                argout = eval(argin,self.__globals,self.__locals)
            except SyntaxError:
                # interpretation as statement
                exec argin in self.__globals, self.__locals
                argout = self.__locals.get("y")

        except Exception, exc:
            # handles errors on both eval and exec level
            argout = traceback.format_exc()

        if type(argout)==StringType:
            return argout
        elif isinstance(argout, BaseException):
            return "%s!\n%s" % (argout.__class__.__name__, str(argout))
        else:
            try:
                return pprint.pformat(argout)
            except Exception:
                return str(argout)
        #----- PROTECTED REGION END -----#	//	Skippy.Exec
        return argout
        
#------------------------------------------------------------------
#    AddMonitoring command:
#------------------------------------------------------------------
    def AddMonitoring(self, argin):
        """ Add an attribute to the list of monitored attributes
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".AddMonitoring()")
        #----- PROTECTED REGION ID(Skippy.AddMonitoring) ENABLED START -----#
        try:
            if not argin in self.attributes.keys():
                raise AttributeError("No attribute named %s"%(argin))
            elif argin in self.__monitoredAttr['Special'].keys() or\
                 argin in self.__monitoredAttr['Normal']:
                raise AttributeError("Attribute %s already monitored"%(argin))
            else:
                #manage the property
                try:
                    self.MonitoredAttributes = self.__appendPropertyElement('MonitoredAttributes',argin)
                except Exception,e:
                    self.error_stream("In %s.AddMonitoring(%s) cannot append "\
                                      "to the property: %s"%
                                      (self.get_name(),argin,e))
                    raise e
                #manage the internal list that monitors
                self.debug_stream("Normal monitoring for the attribute %s"
                                  %(argin))
                multiattr = self.get_device_attr()
                attrId = multiattr.get_attr_ind_by_name(argin)
                self.__monitoredAttr['Normal'].append(argin)
                self.__monitoredAttr['NormalIDs'].append(attrId)
                self.set_change_event(argin,True,False)
        except Exception,e:
            self.error_stream("In %s.AddMonitoring(%s) exception: %s"%
                              (self.get_name(),argin,e))
            raise e
        #----- PROTECTED REGION END -----#	//	Skippy.AddMonitoring
        
#------------------------------------------------------------------
#    RemoveMonitoring command:
#------------------------------------------------------------------
    def RemoveMonitoring(self, argin):
        """ Remove an attribute from the list of monitored attributes
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".RemoveMonitoring()")
        #----- PROTECTED REGION ID(Skippy.RemoveMonitoring) ENABLED START -----#
        try:
            if not argin in self.attributes.keys():
                raise AttributeError("No attribute named %s"%(argin))
            elif not argin in self.__monitoredAttr['Special'].keys() and\
                 not argin in self.__monitoredAttr['Normal']:
                raise AttributeError("Attribute %s is not monitored"%(argin))
            else:
                #manage the internal monitors
                self.debug_stream("Removing %s attribute from monitoring"%(argin))
                if argin in self.__monitoredAttr['Special'].keys():
                    self.__monitoredAttr['Special'][argin]['Event'].set()
                elif argin in self.__monitoredAttr['Normal']:
                    self.__monitoredAttr['Normal'].pop(self.__monitoredAttr['Normal'].index(argin))
                    multiattr = self.get_device_attr()
                    attrId = multiattr.get_attr_ind_by_name(argin)
                    self.__monitoredAttr['NormalIDs'].pop(self.__monitoredAttr['NormalIDs'].index(attrId))
                self.set_change_event(argin,False,False)
                #manage the property
                try:
                    self.MonitoredAttributes = self.__popPropertyElement('MonitoredAttributes',argin)
                except Exception,e:
                    self.error_stream("In %s.RemoveMonitoring(%s) cannot remove "\
                                      "from the property: %s"%
                                      (self.get_name(),argin,e))
                    raise e
        except Exception,e:
            self.error_stream("In %s.RemoveMonitoring(%s) exception: %s"%
                              (self.get_name(),argin,e))
            raise e
        #----- PROTECTED REGION END -----#	//	Skippy.RemoveMonitoring
        

#==================================================================
#
#    SkippyClass class definition
#
#==================================================================
class SkippyClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'Instrument':
            [PyTango.DevString,
            "The name of the instrument to use",
            [] ],
        'Port':
            [PyTango.DevUShort,
            "In case of socket interface the port value can be changed",
            [5025]],
        'NumChannels':
            [PyTango.DevUShort,
            "Number of channels available in the instrument, if it has",
            [0]],
        'NumFunctions':
            [PyTango.DevUShort,
            "Number of functions available in the instrument, if it has",
            [0]],
        'MonitoredAttributes':
            [PyTango.DevVarStringArray,
            "When the device is in RUNNING state, the attributes listed here will be monitored (having events) with a period said in the attribute TimeStampsThreashold (or different if specified with a : separator after the attrName)",
            [] ],
        'AutoOn':
            [PyTango.DevBoolean,
            "When device startup, try an on() to connect to the instrument authomatically",
            [True]],
        'AutoStart':
            [PyTango.DevBoolean,
            "When device startup, try an Start() to monitor attributes, if MonitoredAttributes is configuredc, authomatically",
            [True]],
        }


    #    Command definitions
    cmd_list = {
        'IDN':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevString, "none"]],
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'On':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Off':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Exec':
            [[PyTango.DevString, "none"],
            [PyTango.DevString, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'AddMonitoring':
            [[PyTango.DevString, "none"],
            [PyTango.DevVoid, "none"]],
        'RemoveMonitoring':
            [[PyTango.DevString, "none"],
            [PyTango.DevVoid, "none"]],
        }


    #    Attribute definitions
    attr_list = {
        'Idn':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description': "Instrument identification",
            } ],
        'QueryWindow':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Query Window",
                'unit': "queries",
                'format': "%2d",
                'min value': "1",
                'max warning': "20",
                'description': "When many attributes are requested at the same time, they are grouped in subqueries of this size",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'TimeStampsThreshold':
            [[PyTango.DevFloat,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Time stamps threshold",
                'unit': "seconds",
                'format': "%3.2g",
                'max value': "3",
                'min value': "0.1",
                'description': "This value sets the threshold time to use a cached value or hardware read it",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        }


#------------------------------------------------------------------
#    SkippyClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In Skippy Class  constructor"

#==================================================================
#
#    Skippy class main method
#
#==================================================================
def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(SkippyClass,Skippy,'Skippy')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
