#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        Skippy.py
## 
## Project :     SCPI
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Standard Commands for Programmable Instruments (SCPI) DeviceServer """

__all__ = ["Skippy", "SkippyClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(Skippy.additionnal_import) ENABLED START -----#
import socket
import time
import traceback
import communicator
import instructionSet
import numpy,struct
#----- PROTECTED REGION END -----#	//	Skippy.additionnal_import

##############################################################################
## Device States Description
##
## OFF : No connection stablished with the instrument.
## ON : Connection stablished with the instrument.
## RUNNING : Connection stablished and active monitoring.
## ALARM : Reported errors from the instrument.
## FAULT : Communication error with the instrument.
## INIT : Initialization stage.
##############################################################################

class Skippy (PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------
#----- PROTECTED REGION ID(Skippy.global_variables) ENABLED START -----#

    ######
    #----- section to resolve instrument property
    def getConnectionObj(self,instrumentName):
        if self.isHostName(instrumentName):
            return communicator.bySocket(instrumentName,self.Port,self)
        elif self.isTangoName(instrumentName):
            if self.isVisaDevice(instrumentName):
                return communicator.byVisa(instrumentName,self)
            raise SyntaxError("Instrument device type not identified")
        raise SyntaxError("Instrument name not identified")
    
    def isHostName(self,name):
        try:
            socket.gethostbyname(name)
            self.debug_stream("Recognised the instrument %s as a host name"
                              %(name))
            return True
        except:
            self.debug_stream("Not possible to resolve %s in the network"
                              %(name))
            return False
    
    def isTangoName(self,name):
        try:
            PyTango.DeviceProxy(name)
            self.debug_stream("Recognised the instrument %s as a tango device"
                              %(name))
            return True
        except:
            self.debug_stream("Not possible to have a proxy to something "\
                              "called %s"%(name))
            return False

    def isVisaDevice(self,devName):
        try:
            devClass = PyTango.DeviceProxy(devName).info().dev_class
            if devClass == 'PyVisa':
                self.debug_stream("Device %s is a recognised PyVisa"%(devName))
                return True
            else:
                self.debug_stream("Device %s has %s class"%(devName,devClass))
                return False
        except:
            self.debug_stream("Unable to get the class of the device %s"
                              %(devName))
            return False
    #----- done section to resolve instrument property
    ######
    
    ######
    #----- dynamic attributes builder section
    def builder(self):
        instructionSet.identifier(self.__idn,self)
        
    def unbuilder(self):
        pass #TODO: remove all the dynamic attributes from the current builded.
    
    def __filterAttributes(self,multiattr,data):
        '''Avoid hardware readings of:
           - attributes that are internals to the device
           - attributes that reading is recent (TODO)
        '''
        try:
            t = time.time()
            delta_t = self.attr_TimeStampsThreshold_read
            scalar = []
            spectrum = []
            image = []
            for attr_index in data:
                attrObj = multiattr.get_attr_by_ind(attr_index)
                attrName = attrObj.get_name()
                if not self.attributes.has_key(attrName):
                        self.debug_stream("In %s.__filterAttributes() "\
                                          "excluding %s: is not a hw attr."
                                          %(self.get_name(),attrName))
                else:
                    t_a = self.attributes[attrName]['timestamp']
                    if not t_a == None and t - t_a < delta_t:
                        self.debug_stream("In %s.__filterAttributes() "\
                                          "excluding %s: t < delta_t"
                                          %(self.get_name(),attrName))
                    else:
                        if attrObj.get_data_format() == PyTango.AttrDataFormat.SCALAR:
                            scalar.append(attrName)
                        elif attrObj.get_data_format() == PyTango.AttrDataFormat.SPECTRUM:
                            spectrum.append(attrName)
                            #when an spectrum are required, some reference attributes will be needed
                            if self.attributes.has_key('WaveformDataFormat'):
                                scalar.append('WaveformDataFormat')
                            if self.attributes.has_key('WaveformOrigin'):
                                scalar.append('WaveformOrigin')
                            if self.attributes.has_key('WaveformIncrement'):
                                scalar.append('WaveformIncrement')
                        elif attrObj.get_data_format() == PyTango.AttrDataFormat.IMAGE:
                            image.append(attrName)
                        else:
                            self.error_stream("In %s.__filterAttributes() "\
                                              "unknown data format for "\
                                              "attribute %s"%(self.get_name(),attrName))
            self.debug_stream("In %s.__filterAttributes() scalar list: %s; "\
                              "spectrum list: %s; image list: %s"
                              %(self.get_name(),scalar,spectrum,image))
            #Remove repeated attributes
            for attr in scalar:
                while scalar.count(attr) > 1:
                    scalar.pop(scalar.index(attr))
            for attr in spectrum:
                while spectrum.count(attr) > 1:
                    spectrum.pop(spectrum.index(attr))
            for attr in image:
                while image.count(attr) > 1:
                    image.pop(image.index(attr))
            return scalar,spectrum,image
        except Exception,e:
            self.error_stream("In %s.__filterAttributes(%s) Exception: %s"
                              %(self.get_name(),data,e))
            traceback.print_exc()
            return None
    
    def __preHardwareRead(self,attrList,window=1):
        '''Given a list of attributes to be read, prepare it.
           - Divide the attributes to be read in subsets of QueryWindow size.
           - Build the concatenations of queries per subset.
           Example: QueryWindow = 4
           Input: attrList = [a1,a2,a3,a4,a5,a6,a7,a8,a9,a10]
           Output: subsetsIndexes = [[a1,a2,a3,a4],
                                     [a5,a6,a7,a8],
                                     [a9,a10]]
                   subsetsQueries = ["cmd;cmd;cmd;cmd;",
                                     "cmd;cmd;cmd;cmd;",
                                     "cmd;cmd;"]
        '''
        try:
            self.debug_stream("In %s.__preHardwareRead()"%self.get_name())
            subsetsIndexes = []
            subsetsQueries = []
            for i in range(0,len(attrList),window):
                subsetsIndexes.append(attrList[i:i+window])
                subsetsQueries.append("")
                for j in range(len(subsetsIndexes[len(subsetsIndexes)-1])):
                    attrName = subsetsIndexes[len(subsetsIndexes)-1][j]
                    attrCmd = self.attributes[attrName]['readStr']
                    subsetsQueries[len(subsetsQueries)-1] = "%s%s;"%(subsetsQueries[len(subsetsQueries)-1],attrCmd)
            return subsetsIndexes,subsetsQueries
        except Exception,e:
            self.error_stream("In %s.__preHardwareRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
            return None,None

    def __hardwareScalarRead(self,query):
        '''Given a string with a ';' separated list of scpi commands 'ask'
           to the instrument and return what the instrument responds.
        '''
        return self.__instrument.ask(query)
    def __hardwareSpectrumRead(self,query):
        '''Given a string with a ';' separated list of scpi commands 'ask'
           to the instrument and return what the instrument responds.
        '''
        #return self.__instrument.ask_for_values(query)
        return self.__instrument.ask(query)
        #FIXME: spectrum and scalar are equal, only one method is required

    def __postHardwareScalarRead(self,indexes,answers):
        '''Given the answers organise them in the self.attributes dictionary.
           Example: QueryWindow = 4
           Input: indexes = [[a1,a2,a3,a4],
                             [a5,a6,a7,a8],
                             [a9,a10]]
                  answers = ["ans;ans;ans;ans;",
                             "ans;ans;ans;ans;",
                             "ans;ans;"]
        '''
        t = time.time()
        try:
            for i,answer in enumerate(answers):
                for j,value in enumerate(answer.split('\n')[0].split(';')):
                    attrName = indexes[i][j]
                    try:
                        if self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevBoolean]:
                            self.attributes[attrName]['lastReadValue'] = bool(int(value))
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevUChar,
                                                                   PyTango.CmdArgType.DevUShort,
                                                                   PyTango.CmdArgType.DevShort,
                                                                   PyTango.CmdArgType.DevULong,
                                                                   PyTango.CmdArgType.DevLong,
                                                                   PyTango.CmdArgType.DevULong64,
                                                                   PyTango.CmdArgType.DevLong64]:
                            self.attributes[attrName]['lastReadValue'] = int(value)
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevFloat,
                                                                   PyTango.CmdArgType.DevDouble]:
                            if value == '9.99999E+37':#this is the instrument tag for non measurable
                                self.attributes[attrName]['lastReadValue'] = float('NaN')
                            else:
                                self.attributes[attrName]['lastReadValue'] = float(value)
                        elif self.attributes[attrName]['type'] in [PyTango.CmdArgType.DevString]:
                            self.attributes[attrName]['lastReadValue'] = str(value)
                        else:
                            self.warn_stream("In %s.__postHardwareScalarRead() "\
                                             "Unrecognized data type for %s"
                                             %(self.get_name(),attrName))
                            self.attributes[attrName]['lastReadValue'] = value
                    except Exception,e:
                        self.error_stream("In %s.__postHardwareScalarRead() "\
                                          "Exception of attribute %s: %s"
                                          %(self.get_name(),attrName,e))
                        self.attributes[attrName]['lastReadValue'] = None
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_INVALID
                    else:
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                    finally:
                        self.attributes[attrName]['timestamp'] = t
        except Exception,e:
            self.error_stream("In %s.__postHardwareScalarRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
    
    def __postHardwareSpectrumRead(self,indexes,answers):
        '''Given the answers organise them in the self.attributes dictionary.
           QueryWindow doesn't apply here, the spectrums are made in separated reads
           Input: indexes = [[s1],
                             [s2],
                             [a3]]
                  answers = ["f1,f2,f3,f4,...,fn",
                             "f1,f2,f3,f4,...,fn",,
                             "f1,f2,f3,f4,...,fn",]
           A waveform has always a first character '#'
           The second is a char with the number of elements in the next variable field
           The third, represented with Rs, are the number of elements in the waveform that comes next.
           Example: answer = #532017... means, 5 elements will be in the second
                    field, and there will be 32017 elements in the third.
        '''
        t = time.time()
        try:
            for i,answer in enumerate(answers):
                attrName = indexes[i][0]
                if attrName.startswith('Channel') or attrName.startswith('Function'):
                    if self.attributes.has_key('WaveformDataFormat') and \
                       self.attributes.has_key('WaveformOrigin') and \
                       self.attributes.has_key('WaveformIncrement'):
                        dataFormat = self.attributes['WaveformDataFormat']['lastReadValue']
                        if dataFormat.startswith('ASC'):
                            self.attributes[attrName]['lastReadValue'] = numpy.fromstring(answer,dtype=float,sep=',')
                            self.attributes[attrName]['timestamp'] = t
                            self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                        else:
                            #process the header
                            if not answer[0] == '#':
                                self.error_stream("Wrong data receiver for the "\
                                                  "attribute %s"%attrName)
                            nBytesLengthBlock = int(answer[1])
                            nBytesWaveBlock = int(answer[2:nBytesLengthBlock+2])
                            waveBytes = answer[nBytesLengthBlock+2:nBytesWaveBlock]
                            self.debug_stream("In %s.__postHardwareSpectrumRead() "\
                                              "waveform data: header size %d bytes, "\
                                              "wave size %d bytes"
                                              %(self.get_name(),nBytesLengthBlock,nBytesWaveBlock))
                            if dataFormat.startswith('BYT'):
                                format = 'b'#signed char, 1byte
                                divisor = 1
                            elif dataFormat.startswith('WORD'):
                                format = 'h'#signed short, 2byte
                                divisor = 2
#                             elif dataFormat.startswith('LON'):
#                                 pass
                            else:
                                self.error_stream("Cannot decodify data receiver "\
                                                  "for the attribute %s"%attrName)
                                self.attributes[attrName]['lastReadValue'] = []
                                self.attributes[attrName]['timestamp'] = t
                                self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_INVALID
                            nCompletBytes = len(waveBytes)-(len(waveBytes)%divisor)
                            if not len(waveBytes)%4 == 0:
                                self.debug_stream("nIncompleteBytes = %d"%(len(waveBytes)%divisor))
                            #convert the received input to integers
                            unpackInt = struct.unpack(format*(nCompletBytes/divisor),waveBytes[:nCompletBytes])
                            #expand the input when each float is codified in less than 4 bytes
                            floats = numpy.array(unpackInt,dtype=float)
                            waveorigin = self.attributes['WaveformOrigin']['lastReadValue']
                            waveincrement = self.attributes['WaveformIncrement']['lastReadValue']
                            self.attributes[attrName]['lastReadValue'] = (waveorigin + (waveincrement * floats))
                            self.attributes[attrName]['timestamp'] = t
                            self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
                    else:
                        self.warn_stream("In %s.__postHardwareSpectrumRead() "\
                                         "Unrecognised spectrum attribute, "\
                                         "storing raw data"%(self.get_name()))
                        self.attributes[attrName]['lastReadValue'] = answer
                        self.attributes[attrName]['timestamp'] = t
                        self.attributes[attrName]['quality'] = PyTango.AttrQuality.ATTR_VALID
        except Exception,e:
            self.error_stream("In %s.__postHardwareSpectrumRead() Exception: %s"\
                              %(self.get_name(),e))
            traceback.print_exc()
    
    @instructionSet.AttrExc
    def read_attr(self, attr):
        attrName = attr.get_name()
        if self.attributes.has_key(attrName):
            value = self.attributes[attrName]['lastReadValue']
            timestamp = self.attributes[attrName]['timestamp']
            quality = self.attributes[attrName]['quality']
            if self.attributes[attrName]['dim'] == 0:
                attr.set_value_date_quality(value,timestamp,quality)
            elif self.attributes[attrName]['dim'] == 1:
                attr.set_value_date_quality(value,timestamp,quality,len(value))
        elif attrName.endswith("Step"):
            parentAttrName = attrName.split('Step')[0]
            value = self.attributes[parentAttrName]['rampStep']
            attr.set_value(value)
        elif attrName.endswith("StepSpeed"):
            parentAttrName = attrName.split('StepSpeed')[0]
            value = self.attributes[parentAttrName]['rampStepSpeed']
            attr.set_value(value)
        else:
            raise AttributeError("Invalid read of the attribute %s"
                                 %(attrName))

    @instructionSet.AttrExc
    def write_attr(self, attr):
        '''The execution of this method starts with three different branches:
           - An instrument attribute to be send. This splits in two branches also:
             - Direct write
             - Launch a thread (if not yet) to drive a ramp to the setpoint
           - The other two are the internal ramp attributes
           - Other case, raise an exception
        '''
        attrName = attr.get_name()
        data = []
        attr.get_write_value(data)
        if self.attributes.has_key(attrName):
            self.attributes[attrName]['lastWriteValue'] = data[0]
            if self.attributes[attrName].has_key('rampThread') and \
               not (self.attributes[attrName]['rampStep'] == 0.0 \
                    or self.attributes[attrName]['rampStep'] == 0.0) and\
               self.attributes[attrName]['rampThread'] == None:
                self.attributes[attrName]['rampThread'] = threading.Thread(target=self.rampSteeper,args=(attrName))
                self.attributes[attrName]['rampThread'].setDaemon(True)
                self.attributes[attrName]['rampThread'].start()
            else:
                cmd = self.attributes[attrName]['writeStr'](data[0])
                self.debug_stream("In %s.write_attr() sending: %s"%(self.get_name(),cmd))
                self.__instrument.write(cmd)
        elif attrName.endswith("Step"):
            parentAttrName = attrName.split('Step')[0]
            self.attributes[parentAttrName]['rampStep'] = data[0]
        elif attrName.endswith("StepSpeed"):
            parentAttrName = attrName.split('StepSpeed')[0]
            self.attributes[parentAttrName]['rampStepSpeed'] = data[0]
        else:
            raise AttributeError("Invalid write of the attribute %s"
                                 %(attrName))

    def rampSteeper(self,attrName):
        #prepare
        backup_state = self.get_state()
        self.change_state(PyTango.DevState.MOVING)
        attrReadCmd = self.attributes[attrName]['readStr']
        #move
        self.attributes[attrName]['lastReadValue'] = self.__instrument.ask(attrReadCmd)
        current_pos = self.attributes[attrName]['lastReadValue']
        self.info_stream("In %s.rampSteeper(): started the movement from %f"
                         %(self.get_name(),current_pos))
        while not current_pos == self.attributes[attrName]['lastWriteValue']:
            if current_pos > self.attributes[attrName]['lastWriteValue']:
                if current_pos - self.attributes[attrName]['lastWriteValue'] < self.attributes[attrName]['rampStep']:
                    current_pos = self.attributes[attrName]['lastWriteValue']
                else: current_pos -= self.attributes[attrName]['rampStep']
            elif current_pos < self.attributes[attrName]['lastWriteValue']:
                if self.attributes[attrName]['lastWriteValue'] - current_pos < self.attributes[attrName]['rampStep']:
                    current_pos = self.attributes[attrName]['lastWriteValue']
                else: current_pos += self.attributes[attrName]['rampStep']
            attrWriteCmd = self.attributes[attrName]['writeStr'](current_pos)
            self.debug_stream("In %s.write_attr() sending: %s"%(self.get_name(),cmd))
            self.__instrument.write(attrWriteCmd)
            time.sleep(self.attributes[attrName]['rampStepSpeed'])
        self.info_stream("In %s.rampSteeper(): finished the movement at %f"
                         %(self.get_name(),current_pos))
        #close
        self.change_state(backup_state)
        self.attributes[attrName]['rampThread'] = None

    #----- done dynamic attributes builder section
    ######

    ######
    #----- event manager section
    def fireEventsList(self,eventsAttrList):
        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                self.debug_stream("In %s.fireEventsList() attribute: %s"%(self.get_name(),attrEvent[0]))
                if len(attrEvent) == 3:#specifies quality
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,PyTango.AttrQuality.ATTR_VALID)
            except Exception,e:
                self.error_stream("In %s.fireEventsList() Exception with attribute %s: %s"%(self.get_name(),attrEvent[0],e))
                traceback.print_exc()
    #@todo: clean the important logs when they loose importance.
    def change_state(self,newstate):
        self.debug_stream("In %s.change_state(%s)"%(self.get_name(),str(newstate)))
        if newstate != self.get_state():
            self.set_state(newstate)
            self.push_change_event('State',newstate)
    def cleanAllImportantLogs(self):
        self.debug_stream("In %s.cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")
    def addStatusMsg(self,current,important = False):
        self.debug_stream("In %s.addStatusMsg()"%self.get_name())
        msg = ""#The device is in %s state.\n"%(self.get_state())
        for ilog in self._important_logs:
            msg = "%s%s\n"%(msg,ilog)
        status = "%s%s"%(msg,current)
        self.set_status(status)
        self.push_change_event('Status',status)
        if important and not current in self._important_logs:
            self._important_logs.append(current)
    #----- done event manager section
    ######

#----- PROTECTED REGION END -----#	//	Skippy.global_variables
#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In " + self.get_name() + ".__init__()")
        Skippy.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.debug_stream("In " + self.get_name() + ".delete_device()")
        #----- PROTECTED REGION ID(Skippy.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.delete_device

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.debug_stream("In " + self.get_name() + ".init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Idn_read = ''
        self.attr_QueryWindow_read = 0
        self.attr_TimeStampsThreshold_read = 0.0
        #----- PROTECTED REGION ID(Skippy.init_device) ENABLED START -----#
        self.attributes={}
        self._important_logs = []
        self.set_state(PyTango.DevState.INIT)
        self.set_change_event('State',True,False)
        self.set_change_event('Status',True,False)
        self.get_device_properties(self.get_device_class())
        try:
            self.__instrument = self.getConnectionObj(self.Instrument)
        except SyntaxError,e:
            self.error_stream("Error in the instrument name: %s"%(e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("%s: review the instrument property"%(e))
            return
        except Exception,e:
            self.error_stream("Generic exception: %s"%(e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("initialisation exception: %s"%(e))
            return
        self.change_state(PyTango.DevState.OFF)
        self.On()
        #----- PROTECTED REGION END -----#	//	Skippy.init_device

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.debug_stream("In " + self.get_name() + ".always_excuted_hook()")
        #----- PROTECTED REGION ID(Skippy.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.always_executed_hook

#==================================================================
#
#    Skippy read/write attribute methods
#
#==================================================================

#------------------------------------------------------------------
#    Read Idn attribute
#------------------------------------------------------------------
    def read_Idn(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_Idn()")
        #----- PROTECTED REGION ID(Skippy.Idn_read) ENABLED START -----#
        self.attr_Idn_read = self.__idn
        #----- PROTECTED REGION END -----#	//	Skippy.Idn_read
        attr.set_value(self.attr_Idn_read)
        
#------------------------------------------------------------------
#    Read QueryWindow attribute
#------------------------------------------------------------------
    def read_QueryWindow(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_QueryWindow()")
        #----- PROTECTED REGION ID(Skippy.QueryWindow_read) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.QueryWindow_read
        attr.set_value(self.attr_QueryWindow_read)
        
#------------------------------------------------------------------
#    Write QueryWindow attribute
#------------------------------------------------------------------
    def write_QueryWindow(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_QueryWindow()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(Skippy.QueryWindow_write) ENABLED START -----#
        self.attr_QueryWindow_read = int(data)
        #----- PROTECTED REGION END -----#	//	Skippy.QueryWindow_write
        
#------------------------------------------------------------------
#    Read TimeStampsThreshold attribute
#------------------------------------------------------------------
    def read_TimeStampsThreshold(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_TimeStampsThreshold()")
        #----- PROTECTED REGION ID(Skippy.TimeStampsThreshold_read) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.TimeStampsThreshold_read
        attr.set_value(self.attr_TimeStampsThreshold_read)
        
#------------------------------------------------------------------
#    Write TimeStampsThreshold attribute
#------------------------------------------------------------------
    def write_TimeStampsThreshold(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_TimeStampsThreshold()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(Skippy.TimeStampsThreshold_write) ENABLED START -----#
        self.attr_TimeStampsThreshold_read = float(data)
        #----- PROTECTED REGION END -----#	//	Skippy.TimeStampsThreshold_write
        



#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self, data):
        self.debug_stream("In " + self.get_name() + ".read_attr_hardware()")
        #----- PROTECTED REGION ID(Skippy.read_attr_hardware) ENABLED START -----#
        #TODO: !! spectrumList
        try:
            multiattr = self.get_device_attr()
            scalarList,spectrumList,imageList = self.__filterAttributes(multiattr, data)
            if not len(scalarList) == 0:
                indexes,queries = self.__preHardwareRead(scalarList,self.attr_QueryWindow_read)
                answers = []
                for query in queries:
                    answers.append(self.__hardwareScalarRead(query))
                self.debug_stream("In %s.read_attr_hardware() scalar answers: %s"\
                                  %(self.get_name(),answers))
                self.__postHardwareScalarRead(indexes,answers)
            if not len(spectrumList) == 0:
                indexes,queries = self.__preHardwareRead(spectrumList,1)
                answers = []
                for query in queries:
                    answers.append(self.__hardwareSpectrumRead(query))
                self.debug_stream("In %s.read_attr_hardware() spectrum answers number: %s"\
                                  %(self.get_name(),len(answers)))
                self.__postHardwareSpectrumRead(indexes,answers)
            if not len(imageList) == 0:
                self.error_stream("Excluding 2 dimensional attributes")
        except Exception,e:
            self.error_stream("In %s.read_attr_hardware() Exception: %s"\
                              %(self.get_name(),e))
        #----- PROTECTED REGION END -----#	//	Skippy.read_attr_hardware


#==================================================================
#
#    Skippy command methods
#
#==================================================================

#------------------------------------------------------------------
#    IDN command:
#------------------------------------------------------------------
    def IDN(self):
        """ Request identification to the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In " + self.get_name() +  ".IDN()")
        argout = ''
        #----- PROTECTED REGION ID(Skippy.IDN) ENABLED START -----#
        self.__idn = self.__instrument.ask("*IDN?")
        argout = self.__idn
        #----- PROTECTED REGION END -----#	//	Skippy.IDN
        return argout
        
#------------------------------------------------------------------
#    Start command:
#------------------------------------------------------------------
    def Start(self):
        """ Start an active monitoring.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Start()")
        #----- PROTECTED REGION ID(Skippy.Start) ENABLED START -----#
        raise NotImplementedError("Not implemented")
        #----- PROTECTED REGION END -----#	//	Skippy.Start
        
#------------------------------------------------------------------
#    Stop command:
#------------------------------------------------------------------
    def Stop(self):
        """ Stop the active monitoring.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Stop()")
        #----- PROTECTED REGION ID(Skippy.Stop) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Skippy.Stop
        
#------------------------------------------------------------------
#    On command:
#------------------------------------------------------------------
    def On(self):
        """ Stablish communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".On()")
        #----- PROTECTED REGION ID(Skippy.On) ENABLED START -----#
        try:
            self.__instrument.connect()
        except:
            self.error_stream("Cannot connect to the instrument")
        else:
            self.__idn = self.__instrument.ask("*IDN?")
            self.info_stream("Connected to the instrument and "\
                             "identified as: %s"%(repr(self.__idn)))
            self.change_state(PyTango.DevState.ON)
            self.builder()
        #----- PROTECTED REGION END -----#	//	Skippy.On
        
#------------------------------------------------------------------
#    Off command:
#------------------------------------------------------------------
    def Off(self):
        """ Release the communication with the instrument.
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Off()")
        #----- PROTECTED REGION ID(Skippy.Off) ENABLED START -----#
        try:
            self.__instrument.close()
        except:
            self.error_stream("Cannot disconnect from the instrument")
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Off command failed")
        else:
            self.__idn = ""
            self.info_stream("disconnected to the instrument %s"
                             %(self.Instrument))
            self.change_state(PyTango.DevState.OFF)
            self.unbuilder()
        #----- PROTECTED REGION END -----#	//	Skippy.Off
        
#------------------------------------------------------------------
#    OpenCh command:
#------------------------------------------------------------------
    def OpenCh(self, argin):
        """ In case the instrument has channels open the numbered in the argin.
        
        :param argin: 
        :type: PyTango.DevUShort
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".OpenCh()")
        #----- PROTECTED REGION ID(Skippy.OpenCh) ENABLED START -----#
        if int(argin) > self.NumChannels:
            raise IndexError("Channel number not available")
        #----- PROTECTED REGION END -----#	//	Skippy.OpenCh
        
#------------------------------------------------------------------
#    CloseCh command:
#------------------------------------------------------------------
    def CloseCh(self, argin):
        """ In case the instrument has channels close the numbered in the argin.
        
        :param argin: 
        :type: PyTango.DevUShort
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".CloseCh()")
        #----- PROTECTED REGION ID(Skippy.CloseCh) ENABLED START -----#
        if int(argin) > self.NumChannels:
            raise IndexError("Channel number not available")
        #----- PROTECTED REGION END -----#	//	Skippy.CloseCh
        
#------------------------------------------------------------------
#    OpenFn command:
#------------------------------------------------------------------
    def OpenFn(self, argin):
        """ In case the instrument has functions open the numbered in the argin.
        
        :param argin: 
        :type: PyTango.DevUShort
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".OpenFn()")
        #----- PROTECTED REGION ID(Skippy.OpenFn) ENABLED START -----#
        if int(argin) > self.NumFunctions:
            raise IndexError("Function number not available")
        #----- PROTECTED REGION END -----#	//	Skippy.OpenFn
        
#------------------------------------------------------------------
#    CloseFn command:
#------------------------------------------------------------------
    def CloseFn(self, argin):
        """ In case the instrument has functions close the numbered in the argin.
        
        :param argin: 
        :type: PyTango.DevUShort
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".CloseFn()")
        #----- PROTECTED REGION ID(Skippy.CloseFn) ENABLED START -----#
        if int(argin) > self.NumFunctions:
            raise IndexError("Function number not available")
        #----- PROTECTED REGION END -----#	//	Skippy.CloseFn
        

#==================================================================
#
#    SkippyClass class definition
#
#==================================================================
class SkippyClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'Instrument':
            [PyTango.DevString,
            "The name of the instrument to use",
            [] ],
        'Port':
            [PyTango.DevUShort,
            "In case of socket interface the port value can be changed",
            [5025]],
        'NumChannels':
            [PyTango.DevUShort,
            "Number of channels available in the instrument, if it has",
            [0]],
        'NumFunctions':
            [PyTango.DevUShort,
            "Number of functions available in the instrument, if it has",
            [0]],
        }


    #    Command definitions
    cmd_list = {
        'IDN':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevString, "none"]],
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'On':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Off':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'OpenCh':
            [[PyTango.DevUShort, "none"],
            [PyTango.DevVoid, "none"]],
        'CloseCh':
            [[PyTango.DevUShort, "none"],
            [PyTango.DevVoid, "none"]],
        'OpenFn':
            [[PyTango.DevUShort, "none"],
            [PyTango.DevVoid, "none"]],
        'CloseFn':
            [[PyTango.DevUShort, "none"],
            [PyTango.DevVoid, "none"]],
        }


    #    Attribute definitions
    attr_list = {
        'Idn':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description': "Instrument identification",
            } ],
        'QueryWindow':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Query Window",
                'unit': "queries",
                'format': "%2d",
                'description': "When many attributes are requested at the same time, they are grouped in subqueries of this size",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'TimeStampsThreshold':
            [[PyTango.DevFloat,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Time stamps threshold",
                'unit': "seconds",
                'format': "%3.2g",
                'max value': "3",
                'min value': "0.1",
                'description': "This value sets the threshold time to use a cached value or hardware read it",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        }


#------------------------------------------------------------------
#    SkippyClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In Skippy Class  constructor"

#==================================================================
#
#    Skippy class main method
#
#==================================================================
def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(SkippyClass,Skippy,'Skippy')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
